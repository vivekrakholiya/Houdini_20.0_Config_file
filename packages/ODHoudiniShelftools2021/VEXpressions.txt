#
#       @file       VEXpressions.txt
#       @author     Oliver Hotz (plus all the collected ones over the past few months)
#
#       @since      2018-09-02
#
#       @brief      Varions VEXpression presets for nodes.
#
#

attribwrangle/snippet
    OD Connect NearPoints
    float dist = chf("Distance");
    int nearpts[] = nearpoints(0, @P, dist);

    foreach (int pnt; nearpts) {
        if (pnt != @ptnum) {
            int line = addprim(0, "polyline");
            addvertex(0, line, @ptnum);
            addvertex(0, line, pnt);
        }
    }

attribwrangle/snippet
    OD Localize Matnet Path
    string name = split(s@shop_materialpath, '/')[-1];
    name =  re_replace('[^a-zA-Z0-9]', '_', name);
    if (name == '') name='Unassigned';
    s@shop_materialpath = opfullpath("..") + "/material_network/" + name;

attribwrangle/snippet
    OD PScale Ramp
    @pscale = chramp("Scale", @curveu)*chf("Multiplier");

attribwrangle/snippet
    OD Simple Y Black and White Ramp
    vector min = getbbox_min(0);
    vector max = getbbox_max(0);
    @Cd = fit(@P.y, min.y, max.y, 0, 1);

attribwrangle/snippet
    OD Intrinsic Alembic Frame Offset
    float pop_speed = fit(point(0, "speed", @ptnum), 0, 3, 1, 3);
    float new_speed = @Time * (pop_speed + rand(@ptnum));
    float start_time = chf("start_time");
    float abc_time = 1;
    if(new_speed % 0.5 == 0){
    abc_time = 0.5 + start_time;
    }
    else{
    abc_time = (new_speed % 0.5) + start_time;
    }
    setprimintrinsic(0, "abcframe", @primnum, abc_time, "set");

attribwrangle/snippet
    OD Simple Time Ripple
    float d = length(@P);
    d *= ch('scale');
    d += @Time;
    d = sin(d);
    d = fit(d,-1,1,0,1);
    @P.y = chramp('myramp',d);
    @P.y *= ch('height');    

attribwrangle/snippet
    OD Simple Color CurlNoise
    @Cd = curlnoise(@P*chv('fancyscale')+@Time);  

attribwrangle/snippet
    OD Normals to a point
    vector a = @P;
    vector b = point(1,'P',0);
    @N = b-a;     

attribwrangle/snippet
    OD Velocity from first point outward
    vector origin = point(1,'P',0);
    @v = @P-origin;   

attribwrangle/snippet
    OD Velocity vector
    //Calculate a velocity vector, same result as if you would take a Trail SOP and set it to Compute Velocity.
    //Run in a Wrangle SOP (Run over - Points)
    @v = (new_pos - @P) * (1 / @Timeinc);

attribwrangle/snippet
    OD Remove Outside Pieces after fracture
    if (nprimitivesgroup(geoself(), "outside") > 0) 
    {
        removeprim(geoself(), @primnum, 1);
    }

attribwrangle/snippet
    OD Waves
    int pts[];
    int pt;
    vector pos;
    float d,w;

    pts = nearpoints(1,@P,ch('radius'),chi('number_of_points'));

    pt = pts[0];
    pos = point(1,'P',pt);
    d = distance(@P, pos);
    w = d*ch('freq');
    w -= @Time * ch('speed');
    w = sin(w);
    w *= ch('amp');
    w *= fit(d,0,ch('radius'),1,0);
    @P.y += w;

    pt = pts[1];
    pos = point(1,'P',pt);
    d = distance(@P, pos);
    w = d*ch('freq');
    w -= @Time * ch('speed');
    w = sin(w);
    w *= ch('amp');
    w *= fit(d,0,ch('radius'),1,0);
    @P.y += w;

attribwrangle/snippet
    OD Curly Hair extrusions
    vector offset, pos;
    int pr, pt;
    float stepsize;

    pr = addprim(0,'polyline');
    stepsize = 0.5;

    for (int i = 0; i < 6;i++) {
        offset = curlnoise(@P-@Time+i)*0.2;
        pos = @P + @N * i * stepsize + offset;
        pt = addpoint(0,pos);
        addvertex(0,pr,pt);
    }    

attribwrangle/snippet
    OD Random Instance Wobble
    vector N, up;
    vector4 extrarot, talktalk, wobble;

    N = normalize(@P);
    up = {0,1,0};
    @orient = quaternion(maketransform(N,up));
    extrarot = quaternion(radians(90),{1,0,0});
    talktalk = quaternion(radians(20)*sin(@Time*3), {0,1,0});
    wobble = quaternion({0,0,1}*curlnoise(@P+@Time*0.2));

    @orient = qmultiply(@orient, extrarot);
    @orient = qmultiply(@orient, talktalk);
    @orient = qmultiply(@orient, wobble);

attribwrangle/snippet
    OD Extra Pts from Normal with Noise
    vector offset, pos;
    int pr, pt;
    float stepsize;
    pr = addprim(0,'polyline');
    stepsize = 0.5;
    for (int i = 0; i < 6;i++) {
      offset = curlnoise(@P-@Time+i)*0.2;
      pos = @P + @N * i * stepsize + offset;
      pt = addpoint(0,pos);
      addvertex(0,pr,pt);
    }

attribwrangle/snippet
    OD Group from Material
    string groupname = s@shop_materialpath;
    groupname=split(groupname,'/')[-1];
    setprimgroup(0, groupname, @primnum, 1);

attribwrangle/snippet
    OD 90 Deg rotations for CopyToPoints
     vector axis;
     axis = chv('axis');
     axis = normalize(axis);
     @a = noise(@P+@Time);
     @a = chramp('noise_rerange',@a);
     axis *= trunc(@a*4)*$PI/2;
    @orient = quaternion(axis);

attribwrangle/snippet
    OD Curve Length Using uvtexture (nurbs) (run over prims)
    //needs a uvtexture node above set to arclen spline
    vector2 u1 = {0,0};
    vector2 u2 = {1,0};
    f@arcLength = primarclen(@OpInput1, u1, u2, 0);

attribwrangle/snippet
    OD Curve Length via pdist from resample (run over prims)
    for (int p=0;p<npoints(0);p++) {
        @dist+=point(0, "ptdist", p);
    }

attribwrangle/snippet
    OD Curve Length (run over prims)
    //Creates two attributes, one primitive attribute for the total length of each curve and one point attribute for the partial length of the curve up to that point
    int     prim_points[];
    float   length;
    vector  pos_A, pos_B;

    addattrib(geoself(), "point", "length_partial", 0.0);

    prim_points = primpoints(geoself(), @primnum);

    length = 0;

    for (int i = 1; i < len(prim_points); i++){
        getattribute(@OpInput1, pos_A, "point", "P", prim_points[i - 1], 0);
        getattribute(@OpInput1, pos_B, "point", "P", prim_points[i], 0);

        length += distance(pos_A, pos_B);

        setattrib(geoself(), "point", "length_partial", prim_points[i], 0, length, "set");
    }

    f@length = length;

attribwrangle/snippet
    OD Curve Orient (run over prims)
    //Creates a orient attribute along each curve. A point normal vector attribute pointing along the curve is needed. 
    //Uncomment line 21 if you have a unique up vector point attribute for each curve that you want to use.

    //Run in a Wrangle SOP (Run over - Primitives)

    addattrib(geoself(), "point", "up", {0, 0, 0});
    addattrib(geoself(), "point", "side", {0, 0, 0});
    addattrib(geoself(), "point", "orient", {0, 0, 0, 0});

    int curve_pts[];

    matrix3 matx;
    vector  v_align_to, v_align_from, v_up, v_side;
    vector4 quat;

    vector  v_ref = {1, 0, 0};

    curve_pts = primpoints(geoself(), @primnum);

    for (int i = 0; i < len(curve_pts); i++)
    {
            if ( i == 0 )
            {
                    // For the first point
                    getattribute(@OpInput1, v_align_to, "point", "N", curve_pts[0], 0);
                    //getattribute(@OpInput1, v_ref, "point", "up", curve_pts[0], 0);

                    v_up    = cross(normalize(v_align_to), normalize(v_ref));
                    v_side  = cross(normalize(v_align_to), normalize(v_up));

                    setattrib(geoself(), "point", "up",     curve_pts[0], 0, v_up,     "set");
                    setattrib(geoself(), "point", "side",   curve_pts[0], 0, v_side,   "set");

                    matx = lookat({ 0, 0, 0 }, v_align_to, v_up);
                    quat = quaternion(matx);

                    setattrib(geoself(), "point", "orient", curve_pts[0], 0, quat, "set");  
            } 
            
            // Get the current points normal
            getattribute(@OpInput1, v_align_from, "point", "N", curve_pts[i], 0);
            
            matx = dihedral(v_align_to, v_align_from);

            v_align_to  = normalize(v_align_from);
            v_up        = normalize(v_up * matx);
            v_side      = normalize(v_side * matx);

            setattrib(geoself(), "point", "up",     curve_pts[i], 0, v_up,     "set");
            setattrib(geoself(), "point", "side",   curve_pts[i], 0, v_side,   "set");

            matx = lookat({ 0, 0, 0 }, v_align_to, v_up);
            quat = quaternion(matx);

            setattrib(geoself(), "point", "orient", curve_pts[i], 0, quat, "set");
    }


attribwrangle/snippet
    OD Curve Multi Carve
    //Let's you carve several curves at one based on a unique primitive carve attribute for each curve. Based on point number and depends on a point U Map attribute between 0-1 on each curve.

    //Run in a Wrangle SOP (Run over - Primitives)

    int prim_points[], carve_point_start, carve_point_end;
    float carve_start, carve_end, umap;
    vector pos_u;

    prim_points = primpoints(geoself(), @primnum);

    //carve_start = f@carve_start;
    //carve_end = f@carve_start;

    carve_start = ch("carve_start");
    carve_end = ch("carve_end");

    if ( carve_start >= carve_end )
        removeprim(geoself(), @primnum, 1);
    else {
        carve_point_start = -1;
        carve_point_end = -1;
        
        // Carve Start
        for ( int i = len(prim_points)-1; i >= 0; i-- ){
            
            getattribute(@OpInput1, umap, "point", "umap", prim_points[i], 0);
            
            if ( umap < carve_start ){
                 
                carve_point_start = i;
                
                if ( i != len(prim_points) + 1 ){
                    
                    for ( int j = i - 1; j >= 0; j-- ){
                        removepoint(geoself(), prim_points[j]);
                    }
                    break;
                }
            }
        }
        
        // Carve End
        for ( int i = 0; i < len(prim_points); i++ ){
            
            getattribute(@OpInput1, umap, "point", "umap", prim_points[i], 0);
                
            if ( umap > carve_end ){
                                    
                carve_point_end = i;
                
                if ( i != len(prim_points) + 1 ){
                    
                    for ( int j = i + 1; j < len(prim_points); j++ ){
                        removepoint(geoself(), prim_points[j]);
                    }
                    break;
                }
            }
        }
        
        if ( carve_point_start >= 0 ){
            pos_u = primuv(@OpInput1, "P", @primnum, set(carve_start, 0, 0));
            setattrib(geoself(), "point", "P", prim_points[carve_point_start], 0, pos_u, "set");
        }
        
        if ( carve_point_end >= 0 ){
            pos_u = primuv(@OpInput1, "P", @primnum, set(carve_end, 0, 0));
            setattrib(geoself(), "point", "P", prim_points[carve_point_end], 0, pos_u, "set");
        }
    }

attribwrangle/snippet
    OD Multi Skin
    //A prim_id primitive attribute is needed to separate each group of primitives
    //Run in a Wrangle SOP (Run over - Primitives)

    int prim_A_points[], prim_B_points[], newPrim_points[], prim, num_prim, prim_id[];

    num_prim = nprimitives(@OpInput1);

    removeprim(geoself(), @primnum, 0);

    if ( @primnum < num_prim - 1 ){
        
        getattribute(@OpInput1, prim_id[0], "primitive", "prim_id", @primnum, 0);
        getattribute(@OpInput1, prim_id[1], "primitive", "prim_id", @primnum + 1, 0);
        
        if ( prim_id[0] == prim_id[1] ){
            prim_A_points = primpoints(geoself(), @primnum);
            prim_B_points = primpoints(geoself(), @primnum + 1);
                
            for ( int i = 0; i < len(prim_A_points); i++ ){
                
                prim = addprim(geoself(), "poly");
                
                if ( i == len(prim_A_points) - 1 ){
                    addvertex(geoself(), prim, prim_B_points[i]);
                    addvertex(geoself(), prim, prim_B_points[0]);
                    addvertex(geoself(), prim, prim_A_points[0]);
                    addvertex(geoself(), prim, prim_A_points[i]);
                }
                else {
                    addvertex(geoself(), prim, prim_B_points[i]);
                    addvertex(geoself(), prim, prim_B_points[i + 1]);
                    addvertex(geoself(), prim, prim_A_points[i + 1]);
                    addvertex(geoself(), prim, prim_A_points[i]);
                }
            }
        }
    }

attribwrangle/snippet
    OD Curve Sections
    //Creates a unique primitive for each section of a curve
    //Run in in a Wrangle SOP (Run Over - Primitive)

    int prim_points[], prim, point_A, point_B;
    vector pos_A, pos_B;
    prim_points = primpoints(geoself(), @primnum);

    for ( int i = 1; i < len(prim_points); i++ )
    {
        prim = addprim(geoself(), "polyline");
        
        pos_A = attrib( 0, "point", "P", prim_points[i - 1] );
        pos_B = attrib( 0, "point", "P", prim_points[i] );
        
        point_A = addpoint( geoself(), pos_A );
        point_B = addpoint( geoself(), pos_B );
            
        addvertex(geoself(), prim, point_A );
        addvertex(geoself(), prim, point_B );
    }
    removeprim(geoself(), @primnum, 1);

attribwrangle/snippet
    OD Curve Wrap
    // project first point
    vector minpos = minpos(1, @P);
    @P = minpos;
    vector currentpos = @P;

    // set up initial variables
    vector dir = chv("axis");
    int newprim = addprim(0, "polyline");

    for( int i=0; i < chi("number_of_pounts"); i++ ) {
        // check N of closest point to the currently processed point on surface
        int closept = nearpoint(1, currentpos);
        vector closeN = point(1, "N" ,closept);

        // calculate new point position
        vector newpos = normalize(cross(closeN, dir + curlnoise(currentpos + i * 0.01) * ch("noise"))) * ch("stepsize");

        // reproject new point position onto surface
        vector projectpos = minpos(1, currentpos + newpos);

        // draw new point with layer offset
        int newpt = addpoint(0, projectpos + closeN * ch("offset") * 0.00001 * i);
        addvertex(0, newprim, newpt);
        
        // set the new point to be the currentpos for next iteraction
        currentpos = projectpos;
    }﻿    

attribwrangle/snippet
    OD Add Noise to (Curve)
    @P += ch('scale')*curlnoise(ch('offset')+@P*ch('freq')+@primnum)*chramp('mask',@curveu);

attribwrangle/snippet
    OD Simple Point Infect (@infect)
    if(@infect == 0){
        float searchrad = chf("Search_Radius");
        int maxresults = chi("Max_Results");
        int spnts[] = nearpoints(0, @P, searchrad, maxresults);
        foreach(int pt;spnts){
            if(point(0,"infect",pt) == 1){
              @infect = 1;
              @Cd = {1,0,0};
            }
        }
    }

attribwrangle/snippet
    OD Dihedral Xform Align
    vector pos = point(1, "P", @ptnum);
    vector norm = point(1, "N", @ptnum);

    @P = pos;
    //vector aim = point(1,'P',0)-@P;
    @orient = dihedral({-1,0,0},norm);
    3@xform = qconvert(@orient);    

attribwrangle/snippet
    OD Rotate around edge
    matrix3 rotm;
    vector scale, postrotation;
    vector4 orient;
    matrix xform;
    vector p0,p1;
    int ptoffset = chi("Point_Offset");

    i[]@points = primpoints(0,@primnum); // list of points in prim

    // get @P of first and second point
    p0 = point(0,'P',@points[0+ptoffset]);
    p1 = point(0,'P',@points[1+ptoffset]);

    v@pivot = (p0+p1)/2; // ie, point halfway between
    v@axis = normalize(p0-p1); // subtract 2 points to get vector // NB! THIS IS THE AXIS OF ROTATION can be @N or random vector

    // first calculate rotation around the axis, convert to orient
    rotm = ident();

    float angle = radians(chf("Degrees")); // we can ammend the angle by angle += float(@primnum*chf{"waveoffset"});

    rotate(rotm, angle, v@axis);
    orient = quaternion(rotm);
        
    // create a transform matrix using orient and pivot
    scale = 1;
    postrotation = 0;
    xform = instance( v@pivot, @N, scale, postrotation, orient, v@pivot);

    // move the point
    @P *=xform;

attribwrangle/snippet
    OD Particle Opacity Random over NAge
    @Alpha = chramp("alpha_over_life", @nage);
    @rnd_Alpha = fit01(rand(@id+12345), 0.0, 1.0);
    @Alpha = lerp(@Alpha, @rnd_Alpha, chramp("lerp", @nage));    

attribwrangle/snippet
    OD Grow Hairs
    // Grow Hairs
    vector dir = { 0, 1, 0 };
    // dir = @N;    // grow in normal direction
    float len = chf("Length");
    int   steps = chi("Steps");
    float jitter = chf("Jitter");
    float seed = 0.12345;

    vector  pos = @P;
    int pr = addprim(geoself(), "polyline");

    // Start the curve with our point
    addvertex(geoself(), pr, @ptnum);
    for (int i = 0; i < steps; i++)
    {
        pos += dir * len / steps;
        pos += (vector(rand( @ptnum + seed )) - 0.5) * jitter;

        // Clone our point to copy attributes
        int pt = addpoint(geoself(), @ptnum);
        // But write a new position
        setpointattrib(geoself(), "P", pt, pos);

        // Connect the new point to our curve.
        addvertex(geoself(), pr, pt);
        seed += $PI;
    }

attribwrangle/snippet
    OD Scatter Arrange to Grid
    float dimX = chf("Width_X");
    float dimY = chf("Width_Y");
    float dimZ = chf("Width_Z");
    @P.x = rint(@P.x/2)*dimX;
    @P.y = rint(@P.y/2)*dimY;
    @P.z = rint(@P.z/2)*dimZ;


attribwrangle/snippet
    OD Delete Edge Points
    int pcloud = pcopen(0, "P", @P, 2.1, 10);
    if(pcnumfound(pcloud) < 5)
    {
        removepoint(0, @ptnum);
    }    

attribwrangle/snippet
    OD Pick Random Point
    int top[], bottom[];

    vector pos;

    for (int pt = 0; pt < npoints(0); pt++)
    {
        pos = point(0, "P", pt);
        
        if ((int)rint(pos.y == 0))
        {
            append(bottom, pt);
        }
        else
        {
            append(top, pt);
        }
    }

    float seed = ch("seed");
    float bot_weight = ch("bottom_weight");

    int rand_num, array_len, array_pos;

    if (len(top) == 0 || len(bottom) == 0)
    {
        rand_num = (int)rint(fit(rand(seed+67), 0, 1, 0, npoints(1)-1));
    }
    else
    {
        if (rand(seed) < bot_weight)
        {
            array_len = len(bottom);
            array_pos = (int)rint(fit(rand(seed+67), 0, 1, 0, array_len-1));
            rand_num = bottom[array_pos];
        }
        else
        {
            array_len = len(top);
            array_pos = (int)rint(fit(rand(seed+67), 0, 1, 0, array_len-1));
            rand_num = top[array_pos];
        }
    }

    for (int pt = 0; pt < npoints(0); pt++)
    {
        if (pt != rand_num)
        {
           removepoint(0, pt);
        }
    }    

attribwrangle/snippet
    OD Random text as a point string attribute
    string alphabet[] = string[](array("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"));
    s@text = alphabet[int(fit01(rand(@ptnum), 0, len(alphabet) - 1))];

attribwrangle/snippet
    OD Random Groups
    int my_rand = int(rand(@ptnum) * 10);
    setpointgroup(geoself(), sprintf("points_%g", (@ptnum + my_rand) % ch("num_groups") ), @ptnum, 1, "set");

attribwrangle/snippet
    OD Check if Primitive is Square
    int primedge = primhedge(0,@elemnum);
    int nexthedge = hedge_next(0,primedge);
    int dstpt1 = hedge_dstpoint(0,primedge);
    int srcpt1 = hedge_srcpoint(0,primedge);
    int dstpt2 = hedge_dstpoint(0,nexthedge);

    vector p0 = point(0,'P',srcpt1);
    vector p1 = point(0,'P',dstpt1);
    vector p2 = point(0,'P',dstpt2);

    float d1 = distance(p0,p1);
    float d2 = distance(p1, p2);

    if (abs(d1-d2) <= ch("tolerance")) {
        setprimgroup(0, "square", @elemnum, 1);

    }

attribwrangle/snippet
    OD Stick points to animated geometry
    //Create TimeShift SOP after animated geo, Scatter SOP and Attribute Wrangler. Connect scatter, timeShift, animated geo to inputs 0, 1 and 2 of the wrangle.

    int prim;
    vector uv;

    // What prim the scatterd point is close to, and position of this prim in uv space
    xyzdist(1, @P, prim, uv);
    // Set scattered point position 
    @P = primuv(2, "P", prim, uv);

attribwrangle/snippet
    OD Flatten Surface Bottom
    float min = ch("flatten_distance") + getbbox_min(0).y;
    float max = getbbox_max(0).y;
    float Y = clamp(@P.y, min, max);

    @P = set(@P.x, Y, @P.z);    

attribwrangle/snippet
    OD Phylotaxis
    int count = 400;
    float bound = 10.0;
    float tau = 6.28318530; // 2*$PI
    float phi = (1+ sqrt(5))/2; // Golden ratio = 1.618
    float golden_angle = (2 - phi)*tau; // In radians(*tau)
    vector pos = {0,0,0};
    float radius = 1.0;
    float theta = 0;
    int pt;

    vector polar_to_cartesian(float theta; float radius){
        return set(cos(theta)*radius, 0, sin(theta)*radius);
    }

    for (int n=0; n<count; n++){
        radius = bound * pow(float(n)/float(count), ch('power'));
        theta += golden_angle;
        
        pos = polar_to_cartesian(theta, radius);

        // Create UP, pscale and N attr
        pt = addpoint(0, pos);
        setpointattrib(0, "pscale", pt, pow(radius,0.5));
        setpointattrib(0, "N", pt, normalize(-pos));
        setpointattrib(0, "up", pt, set(0,1,0));
    }   

attribwrangle/snippet
    OD Spiral Expanding
    float angle;
    vector pos = {0,0,0}; 
    int npoints = chi('number_of_points');
    float step = radians(ch('sweep'))/npoints;

    for (int n=0; n<npoints; n++) {
        angle = step * n;

        pos.x = sin(angle) * angle; 
        pos.y = angle;
        pos.z = cos(angle) * angle;

        addpoint(0, pos);
    }    


attribwrangle/snippet
    OD Spiral
    float angle;
    vector pos = {0,0,0};
    int npoints = chi('number_of_points');
    float step = radians(ch('sweep'))/npoints;

    for (int n=0; n<npoints; n++) {  
        angle = step * n; // Or: angle += step;
        
        pos.x = cos(angle);
        pos.y = angle/10 ;
        pos.z = sin(angle);

        addpoint(0, pos);
    }    


attribwrangle/snippet
    OD Randomize Copies
    // Define orientation vectors
    @N;
    @up = {0,1,0};

    // Define random position values
    float randPos_X = fit01(rand(@ptnum), -ch('Translate_X'), ch('Translate_X'));
    float randPos_Y = fit01(rand(@ptnum), -ch('Translate_Y'), ch('Translate_Y'));
    float randPos_Z = fit01(rand(@ptnum), -ch('Translate_Z'), ch('Translate_Z'));
    vector randPos = set(randPos_X, randPos_Y, randPos_Z);

    // Define random rotation values
    float randRot_X = fit01(rand(@ptnum), -ch('Rotate_X'), ch('Rotate_X'));
    float randRot_Y = fit01(rand(@ptnum), -ch('Rotate_Y'), ch('Rotate_Y'));
    float randRot_Z = fit01(rand(@ptnum), -ch('Rotate_Z'), ch('Rotate_Z'));

    // Apply random positions
    @P += randPos; 

    // Apply random rotations
    @orient = quaternion(maketransform(@N,@up));
    vector4 rotate_X = quaternion(radians(randRot_X),{1,0,0});
    vector4 rotate_Y = quaternion(radians(randRot_Y),{0,1,0});
    vector4 rotate_Z = quaternion(radians(randRot_Z),{0,0,1});
    @orient = qmultiply(@orient, rotate_X);
    @orient = qmultiply(@orient, rotate_Y);
    @orient = qmultiply(@orient, rotate_Z);

    // Apply random scale
    @scale = fit01(rand(@ptnum), chf('Scale_MIN'), chf('Scale_MAX'));   

attribwrangle/snippet
    OD Find Closest Points
    float maxdist = chf("Max_Distance");
    int maxpoints = chi("Max_Points");

    int closept[] = pcfind(0, 'P', @P, maxdist, maxpoints);   

attribwrangle/snippet
    OD Get Neighbor Points
    // Get number of connected points
    int nbPts = neighbourcount(0,@ptnum);
    // Create "border" group with border points
    i@group_border = nbPts == 3 | nbPts == 2;    

attribwrangle/snippet
    OD Move Points to Center
    //Move an object to the origin and return back
    //Create wrangle to move object to the origin
    // Get center of the oject bounding box (centroid)
    vector min = {0, 0, 0};
    vector max = {0, 0, 0};
    getpointbbox(0, min, max);
    vector centroid = (max + min)/2.0;
    // Build and apply transformation matrix
    vector translate = centroid;
    vector rotate = {0,0,0};
    vector scale = {1,1,1};
    matrix xform = invert(maketransform(0, 0, translate, rotate, scale));
    @P *= xform;
    // Store transformation matrix in attribute
    4@xform_matrix = xform;
    //Create the second wrangle to return it to the original position
    //@P *= invert(4@xform_matrix); 

attribwrangle/snippet
    OD Pop Particles moving to another position (input 1)
    float isON = chf("is_On");
    float maxSpeed = chf("Max_Speed");
    float maxDistance = chf("Max_Distance");

    if (isON == 1)
    {
        @v = set(0,0,0);
        vector desiredPosition = point(1, "P", @id);
        float d = distance(desiredPosition, @P);
        vector desiredVelocity = normalize(desiredPosition - @P);
        desiredVelocity *= maxSpeed;
        if (d < maxDistance)
        {
            @P = desiredPosition;
        }
        else
        {
            @P += desiredVelocity;
        }

    }

attribwrangle/snippet
    OD Sop solver Hinge Position and Rotation
    //get the hinge position
    vector hinge = point(1, 'P', i@ptnum);
    //hardcode the trailer offset, in this case, its 6.35
    float trailerOffset = 6.35;
    //compute the distance between trailerand hinge (both are single pt)
    float dist = distance(@P, hinge);
    //compute new x and z
    float newX = hinge.x + ((@P.x-hinge.x) / dist * trailerOffset);
    float newZ = hinge.z + ((@P.z-hinge.z) / dist * trailerOffset);
    //set the new position
    @P = set(newX, @P.y, newZ);

    //Rotation for the xform
    vector aim = point(1,'P',0)-@P;
    @orient = dihedral({0,0,-1},aim);
    3@xform = qconvert(@orient);    

attribwrangle/snippet
    OD Find Intersecting Primitives
    //run over primtives
    vector p, uv;
    int hitPrimIndex = intersect(0, @P-(@N*0.001) , -N*100, p, uv;);
    if (hitPrimIndex == -1)
    {
        i@group_intersection = 1;
    }    

attribwrangle/snippet
    OD Interpolate density with controlField
    f@density = lerp(f@density, f@density*0.9, f@controlField)


attribwrangle/snippet
    OD Remove CornerPoints
    int mypts[]=nearpoints(0,@P,10,10);
    int pt0 = mypts[1];
    int pt1 = mypts[2];
    vector v0 = normalize(point(0,"P",pt0)-v@P);
    vector v1 = normalize(point(0,"P",pt1)-v@P);
    float angle = acos(dot(v0,v1));

    if(abs(angle-90)>ch("bias"))removepoint(0,@ptnum);    


attribwrangle/snippet
    OD Get Color from Intersection
    vector hitpos,hituv;
    float maxdistance = chf("maxdistance");
    int hitprim = intersect(1,@P,v@N*maxdistance,hitpos,hituv);
    v@Cd = primuv(1,"Cd",hitprim,hituv);


attribwrangle/snippet
    OD Add Point Velocity from OBJ Level Animation
    float timestep = 1.0/$FPS;
    matrix prevxform = optransform(“..”, @Time-timestep);
    matrix xform = optransform(“..”);
    vector pos = @P*prevxform*invert(xform);
    @v = (@P-pos)/timestep;

attribwrangle/snippet
    OD Filling particle holes

	int nbs[] = pcfind(0, 'P', @P, ch('Radius'), chi('MaxPoints'));

	vector dir;
	float len;
	vector newPos;

	foreach(int nei; nbs){
		dir = point(0, 'P', nei) - @P;// new Vector
		len = length(dir) * 0.5; // half distance
		newPos = @P + normalize(dir) * len;

		if(len > ch('Max_Dist')){
			int new = addpoint(0, newPos);
			setpointattrib(0, 'v', new, (v@v + point(0, 'v', nei))*0.5, "set");
		}
	}

attribwrangle/snippet
    OD Hard Edge from Vertex Normals
    // These could be promoted to parameters
    float edge_angle = chf("Edge_Angle");
    string group_name = "seams";

    float cos_theta = cos(1.0 - radians(edge_angle));

    int hedge = primhedge(0, @elemnum);
    int start_hedge = hedge;
    int s = 0;

    // Loop through all half edges on a face and mark any that
    // have a greater angle than edge_angle.
    do {
        int src_vrt = hedge_srcvertex(0, hedge);
        vector src_N = normalize(vertexattrib(0, "N", src_vrt, s));
        int dst_vrt = hedge_dstvertex(0, hedge);
        vector dst_N = normalize(vertexattrib(0, "N", dst_vrt, s));
        
        int equiv_hedge = hedge_nextequiv(0, hedge);
        int equiv_src_vrt = hedge_srcvertex(0, equiv_hedge);
        vector equiv_src_N = normalize(vertexattrib(0, "N", equiv_src_vrt, s));
        int equiv_dst_vrt = hedge_dstvertex(0, equiv_hedge);
        vector equiv_dst_N = normalize(vertexattrib(0, "N", equiv_dst_vrt, s));

        if (! (dot(src_N, equiv_src_N) > cos_theta &&
               dot(dst_N, equiv_dst_N) > cos_theta))
        {
            int src_pt = hedge_srcpoint(0, hedge);
            int dst_pt = hedge_dstpoint(0, hedge);
            setedgegroup(0, group_name, src_pt, dst_pt, 1);
        }
        
        hedge = hedge_next(0, hedge);
    } while (hedge != start_hedge);

attribwrangle/snippet
    OD Set Instance Path String
    int r = rint(fit01(rand(@ptnum), chi("min"), chi("max")));
    s@instancepath = sprintf("op:../../var_%s", r);

#
# POPs
#

popfan/localexpression
    Pass Through
    // Center:
    t = t;
    // Cone angle:
    cone = cone;
    dir = dir;
    windspeed = windspeed;
    airresist = airresist;

popfan/localexpression
    Randomize Airresist by Id
    airresist *= rand(@id);

popfilamentforce/localexpression
    Pass Through
    velscale = velscale;
    airresist = airresist;
    forcescale = forcescale;
    velblend = velblend;

popfilamentforce/localexpression
    Randomize by Id
    airresist *= rand(@id);
    forcescale *= rand(@id);

popforce/localforceexpression
    Randomize Magnitude
    // Assign to a float to force rand to scalar.
    // 0.5 and 1.0 are the min and max scales
    float amt = rand(@id);
    force *= fit01(amt, 0.5, 1.0);

popforce/localforceexpression
    Orbit the Origin
    // length(force) ensures the parameter
    // still has an effect on the scale of
    // the orbit
    vector axis = { 0, 1, 0 };
    vector center = { 0, 0, 0 };
    force = length(force) * cross(@P-center, axis);

popforce/localforceexpression
    Force Until Velocity Reached
    float threshold = 2.0;	// Cut off
    float speed = length(@v);
    
    if (speed > threshold)
    {
	force = 0;
    }

popforce/localforceexpression
    Scale Force According to Proximity to Point
    vector pos = { 0, 2, 0 };	// Point Position
    float radius = 1.0;	        // Radius of effect
    float dist = length(@P - pos);
    dist /= radius;             // Normalize distance
    //force *= 1 - clamp(dist, 0, 1); // simple linear force
    force *= smooth(0, 1, 1-dist); // reversed ease in-out force


popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Age
    // Ease in using age in seconds
    amp *= smooth(0, 1.5, @age);    

popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Normalized Age
    // Ease in based on percentage life
    amp *= smooth(0, 0.2, @nage); 

popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Speed
    // speed determines amplitude of effect
    float min = 0.5;    // minimum speed threshold
    float max = 1.0;    // maximum speed threshold
    float width = 0.1;  // ease in and out feather width
    float vmag = clamp(length(@v), min, max);
    amp *= smooth(min, min + width, vmag) - smooth(max - width, max, vmag);

popforce/localnoiseexpression
popwind/localnoiseexpression
    Scale by Velocity
    // boost noise for lower velocity values
    amp *= fit(length(@v), 0, 0.5, 2, 1);

popdrag/localdragexpression
    Drag by Proximity to Point
    vector target = {0, 1, 0};         // Target position
    float dist = length(@P - target);  // distance to target
    float radius = 2.0;	               // Effect radius
    dist = fit(dist, 0, radius, 0, 1); // fit to range
    airresist *= dist;

popdragspin/localdragexpression
    Drag by Proximity to Point
    vector target = {0, 1, 0};         // Target position
    float dist = length(@P - target);  // distance to target
    float radius = 2.0;	               // Effect radius
    dist = fit(dist, 0, radius, 0, 1); // fit to range
    spinresist *= dist;

popattract/goalcode
    Spread Goal
    float spread = 0.1;
    float seed = 0.1245;
    goal += spread * (vector(rand(@id+seed)) - 0.5);

popattract/forcecode
    Randomize Force Scale
    float	fmin = 0.1;
    float	fmax = 1.0;
    forcescale *= fit01( rand(@id), fmin, fmax );

popcolor/localconstant
    Color by Velocity Magnitude
    // Color red by velocity magnitude
    float vmax = 1.0;
    color = set(fit(length(@v), 0, vmax, 0, 1), 0, 0);


popcolor/localconstant
    Color by Condition
    // Condition is Position Y greater than 1.
    // Use any attribute test you wish.
    if (@P.y > 1.0)
    {
	color = color;	// Set to parameter value
    }
    else
    {
	color = @Cd;	// Restore
    }

popcolor/localconstant
    Color by Proximity
    vector center = {0,1,0};
    float  radius = 2.0;
    color = fit(length(@P - center), 0, radius, 1, 0); // reverse fit index

popinstance/localexpression
    Random Scale
    // Note you have to turn on the pscale option for this
    // to work!
    pscale *= rand(@id);

popkill/rulecode
    Kill by Condition
    dead = (@P.y > 1) ? 1 : 0;

poplocalforce/localforce
    Randomize Thrust, Lift and Side Slip
    float seed = 0.12345;
    thrust   *= fit01(rand(@id+seed),   0.5, 1);
    lift     *= fit01(rand(@id+seed+0.1),  0.5, 1);
    sideslip *= fit01(rand(@id+seed+0.2), 0.5, 1);

poplookat/code
    Orient to Velocity
    // Force mode to target is direction:
    mode = 1;
    target = @v;

popproperty/localexpression
    Randomize Mass
    float seed = 0.12345;
    mass *= fit01(rand(@id+seed), 0.7, 1);

popproperty/localexpression
    Randomize Particle Scale
    float seed = 0.12345;
    pscale *= fit01(rand(@id+seed), 0.5, 1.5);

popspeedlimit/localexpression
    Randomize Speed and Spin
    float seed = 0.12345;
    speedmin *= fit01(rand(@id+seed),    0.5, 1);
    speedmax *= fit01(rand(@id+seed+.1), 0.5, 1);
    spinmin  *= fit01(rand(@id+seed+.2), 0.5, 1);
    spinmax  *= fit01(rand(@id+seed+.3), 0.5, 1);

popvelocity/localexpression
    Pass Through
    scale = scale;
    v = v;

popvelocity/localexpression
    Scale Velocity
    v = @v * scale;

popvelocity/localexpression
    Project onto Vector
    vector nv = normalize(v);
    v = dot(nv, @v) * nv;

popvelocity/localexpression
    Project onto Plane
    vector nv = normalize(v);
    v = @v - dot(nv, @v) * nv;

popvelocity/localexpression
    Set Speed
    // The implicit multiplication by scale will
    // then set the speed.
    v = normalize(@v);

popspin/localexpression
    Pass Through
    // oldspinspeed also exists giving the
    // previous spin in degrees per second
    spinspeed = spinspeed;
    axis = axis;

popspin/localexpression
    Scale Spin Speed
    // We treat the spinspeed as a scale here
    // and ignore the axis.
    axis = @w;
    spinspeed = oldspinspeed * spinspeed;

popspin/localexpression
    Project onto Vector
    vector naxis = normalize(axis);
    axis = dot(naxis, @w) * naxis;
    // Construct the required spinspeed
    spinspeed = degrees( length(axis) );

popspin/localexpression
    Rotate onto Vector
    vector naxis = normalize(axis);
    axis = dot(naxis, @w) * naxis;
    spinspeed = oldspinspeed;

popspin/localexpression
    Project onto Plane
    vector naxis = normalize(axis);
    axis = @w - dot(naxis, @w) * naxis;
    // Construct the required spinspeed
    spinspeed = degrees( length(axis) );

popspin/localexpression
    Rotate onto Plane
    vector naxis = normalize(axis);
    axis = @w - dot(naxis, @w) * naxis;
    spinspeed = oldspinspeed;

popspin/localexpression
    Set Spin Speed
    // The implicit multiplication by spinspeed will
    // then set the speed.
    axis = @w;

#
# Point Wrangle
#
pointwrangle/snippet
    Add Value to Y Position
    @P += {0,1,0};

pointwrangle/snippet
    Flatten Points in Y
    @P = set(@P.x, 0, @P.z);

pointwrangle/snippet
    Add Random to Y Position:
    @P += set(@P.x, rand(@ptnum), @P.z);

pointwrangle/snippet
    Velocity from Surface Normals
    @v = @N; // v from surface normals

pointwrangle/snippet
    Color from Bounding Box
    @Cd = relbbox(0, @P);

pointwrangle/snippet
    Flared Y Velocity Attributes
    float  vely = 1.0;                // Velocity in Y
    vector offset = {0, 0, 0};       // Offset flare center
    float  seed = 0.12345; 	     // seed for rand
    float  randamt = 0.1;	     // amount of randomness to add
    vector bbox = relbbox(0, P);     // bounding box of point
    bbox += offset;		     // transform bbox by offset
    @v = set(bbox.x, vely, bbox.z);  // set v
    @v += rand(seed+@ptnum)*randamt;  // add noise to v

pointwrangle/snippet
    Percent pscale Along Curve:
    @pscale = @ptnum/(@Npt-1.0);  // initialize pscale
    //@pscale = spline("catmull-rom", index, 0,0,0.25,0.3,1,1);

pointwrangle/snippet
    Normalize Surface Normals
    @N = normalize(@N);  // normalize surface normals

pointwrangle/snippet
    Random Point Color:
    float seed = 0.12345; // seed for rand
    @Cd = rand(seed + @ptnum);

pointwrangle/snippet
    Random Y Velocity
    float seed = 0.12345;              // initialize seed
    @v = set(0, rand(@ptnum+seed), 0); // random velocity in Y

pointwrangle/snippet
    Simple Noise to Y Position
    @P = set(@P.x, @P.y + fit01(noise(@P),-1, 1)*0.5, @P.z);

pointwrangle/snippet
    Add Noise to Position
    float amp = 1;                    // amplitude of noise
    float time = Time * 0.5;          // speed time used in offset
    int seed = 1;                     // seed of noise
    int octaves = 1;                  // octaves for turbulence noise
    vector freq = {1,1,1};            // noise frequency
    vector offset = set(0, time, 0);  // animate offset with time in Y
    vector pos = ptransform("space:current", "space:world", @P);
    // uncomment the noise function below you want to use
    @P += noise(pos * freq + offset + seed) * amp;
    //@P += onoise(pos * freq + offset + seed) * amp;
    //@P += hscript_noise(pos * freq + offset + seed) * amp;
    //@P += hscript_rand(pos * freq + offset + seed) * amp; 
    //@P += hscript_turb(pos * freq + offset + seed, octaves) * amp;
    //@P += hscript_sturb(pos * freq + offset + seed, octaves) * amp;

pointwrangle/snippet
    Swap Point Position with Rest
    vector tmp = @P;
    @P = @rest;
    @rest = tmp;

pointwrangle/snippet
    Swap Point Position with UV
    vector tmp = @P;
    @P = @uv;
    @uv = tmp;

pointwrangle/snippet
    Color Based on Threshold
    int condition = (@P.x > 0) ? 1 : 0; // short form if() test
    @Cd = set(condition, 0, 0);        // write condition into red color


pointwrangle/snippet
    Point Group on Threshold
    string group = "mygroup";         // group name to add points to
    int condition = (@P.x > 0) ? 1: 0; // short form if() test
    if (condition)
	addgroup(group, @ptnum);       // if true add point to group
    @Cd = set( condition, 0, 0);      // color if in group

pointwrangle/snippet
    Fetch Second Input Position
    // Second input used as reference geometry
    @P = point(1, "P", @ptnum); // set second input position to first

pointwrangle/snippet
    Fetch Second Input Cd Attribute
    // Second input used as reference geometry
    @Cd = point(1, "Cd", @ptnum);


pointwrangle/snippet
    Fetch Second Input Attribute by id
    // grab attribute by id match from second input
    // id attribute present on both inputs for indexing
    int match_pt = findattribval(1, "point", "id", @id); // matching point
    @P = point(1, "P", match_pt);  // use matching point to fetch attribute

pointwrangle/snippet
    Nearest Point Distance
    // Second input used for reference geometry
    int closept = nearpoint(1, @P);	  // get point number of near point
    vector value = point(1, "P", closept);// get position of near point
    @dist = length(@P - value);           // export distance from nearest point
    @Cd = set(@dist, 0, 0);

#
# Attribute Wrangle
#
attribwrangle/snippet
    Color from Bounding Box
    @Cd = relbbox(0, @P);

attribwrangle/snippet
    Random Point Color:
    float seed = 0.12345; // seed for rand
    @Cd = rand(seed + @ptnum);

attribwrangle/snippet
    Color Based on Threshold
    int condition = (@P.x > 0) ? 1 : 0; // short form if() test
    @Cd = set(condition, 0, 0);        // write condition into red color

attribwrangle/snippet
    Point Group on Threshold
    string group = "mygroup";         // group name to add points to
    int condition = (@P.x > 0) ? 1: 0; // short form if() test
    setpointgroup(geoself(), group, @ptnum, condition);
    @Cd = set( condition, 0, 0);      // color if in group

attribwrangle/snippet
    Fetch Second Input Cd Attribute
    // Second input used as reference geometry
    // Use prim and @primnum to get a matching primitive attribute.
    @Cd = point(1, "Cd", @ptnum);

attribwrangle/snippet
    Fetch Second Input Attribute by id/name

    // grab attribute by id match from second input
    // id attribute present on both inputs for indexing
    int match_pt = findattribval(1, "point", "id", @id); // matching point
    @P = point(1, "P", match_pt);  // use matching point to fetch attribute

    // grab attribute by name attribute
    // int match_prim = findattribval(1, "prim", "name", @name); // matching name
    // @Cd = prim(1, "Cd", match_prim);

attribwrangle/snippet
    Nearest Point Distance
    // Second input used for reference geometry
    int closept = nearpoint(1, @P);	  // get point number of near point
    vector value = point(1, "P", closept);// get position of near point
    @dist = length(@P - value);           // export distance from nearest point
    @Cd = set(@dist, 0, 0);

attribwrangle/snippet
    Grow Hairs
    vector dir = { 0, 1, 0 };
    // dir = @N;	// grow in normal direction
    float len = 1.0;
    int   steps = 10;
    float jitter = 0.1;
    float seed = 0.12345;

    vector	pos = @P;
    int		pr = addprim(geoself(), "polyline");

    // Start the curve with our point
    addvertex(geoself(), pr, @ptnum);
    for (int i = 0; i < steps; i++)
    {
	pos += dir * len / steps;
	pos += (vector(rand( @ptnum + seed )) - 0.5) * jitter;

	// Clone our point to copy attributes
	int pt = addpoint(geoself(), @ptnum);
	// But write a new position
	setpointattrib(geoself(), "P", pt, pos);

	// Connect the new point to our curve.
	addvertex(geoself(), pr, pt);
	seed += $PI;
    }

attribwrangle/snippet
    Get Neighbouring Points into Attribute
    i[]@neighbours = neighbours(0, @ptnum);

attribwrangle/snippet
    Average Neighbouring Points
    int n[] = neighbours(0, @ptnum);
    vector avgP = @P;

    // Loops over all elements of n, setting pt
    // to be the value of each element
    foreach (int pt; n)
    {
	avgP += point(0, "P", pt);
    }

    // +1 because we included ourself.
    avgP /= len(n)+1;
    @P = avgP;

#
# VEX Deform
#
deformationwrangle/snippet
    Pass Through
    pos = pos;
    xform = xform;

deformationwrangle/snippet
    Twist
    // Hit the Plug button to generate the UI
    // and change axis.
    vector axis = chv('axis');
    vector center = chv('origin');
    float  rate = chf('rotations_per_distance');

    // Find where we are from the center along axis.
    axis = normalize(axis);
    float dist = dot(pos - center, axis);
    float amt = $PI * 2 * rate * dist;

    matrix3	rot = 1;
    rotate(rot, amt, axis);

    pos -= center;
    pos *= rot;
    pos += center;


#
# Volume Wrangle
#
volumewrangle/snippet
    Create Points where Positive
    // You may want to turn on Bind Each to Density to
    // apply to all volumes.
    if (@density > 0)
    {
	addpoint(geoself(), @P);
    }

#
# Popsteer POPs
#
popsteeralign/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum);

popsteeralign/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*120;

popsteercohesion/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteercohesion/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*120;

popsteerobstacle/localexpression
    Randomize Search Distance per Particle
    frontsearchdistance = rand(@ptnum)*10;
    sidesearchdistance = rand(@ptnum)*5;

popsteerobstacle/localexpression
    Scale Avoidance Force by Pscale
    avoidanceforcescale = 10*1/@pscale;
    breakingforcescale = 10*1/@pscale;

popsteerpath/localforceexpression
    Randomize Path Variance and Force per Particle
    forcescale = rand(@ptnum)*10;
    pathvariance = rand(@ptnum)*5;

popsteerseek/localgoalexpression
    Randomize Goal Position per Particle
    // Random goal position in (-10,10) range
    goal.x = (2*rand(@ptnum)-0.5)*10;
    goal.z = (2*rand(@ptnum)+123)-0.5)*10;

popsteerseek/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteerseparate/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteerseparate/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*180;

popsteerseparate/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*180;

popsteerwander/localforceexpression
    Randomize Force XZ direction per Particle
    force.x = (2*rand(@ptnum)-0.5)*10;
    force.z = (2*rand(@ptnum)+123)-0.5)*10;


sprite/localexpression
    Pass Through
    // 0: Uses offset/size
    // 1: Uses textureindex/row/col
    cropmode = cropmode;
    textureoffset = textureoffset;
    texturesize = texturesize;

    textureindex = textureindex;
    texturerow = texturerow;
    texturecol = texturecol;

    spriterot = spriterot;
    spritescale = spritescale;

#
# Group Expression
#
groupexpression/snippet
    Within radius 1 sphere of origin
    length(@P) < 1.0

groupexpression/snippet
    X coordinate less than 0
    @P.x < 0

groupexpression/snippet
    30% chance
    rand(@elemnum) < 0.3

groupexpression/snippet
    Neighbourhood Watch
    neighbourcount(0,@ptnum)==chi("count")

groupexpression/snippet
    Radar
    chi("Axis")==0 ? degrees(acos(normalize(set(@P.x,0,@P.z)).x))<ch("angle") :
    chi("Axis")==1 ? degrees(acos(-normalize(set(@P.x,0,@P.z)).x))<ch("angle") :
    chi("Axis")==2 ? degrees(acos(normalize(set(@P.x,@P.y,0)).y))<ch("angle") :
    chi("Axis")==3 ? degrees(acos(-normalize(set(@P.x,@P.y,0)).y))<ch("angle") :
    chi("Axis")==4 ? degrees(acos(normalize(set(@P.x,0,@P.z)).z))<ch("angle") : degrees(acos(-normalize(set(@P.x,0,@P.z)).z))<ch("angle") 

groupexpression/snippet
    top points
    relbbox(0,@P).y> (1-ch("spread"))

groupexpression/snippet
    bottom points
    relbbox(0,@P).y < ch("spread")

groupexpression/snippet
    midsection points
    abs((relbbox(0,@P).y)-0.5)<ch("spread")

groupexpression/snippet
    Corner Points
    chf("concav_vexity")==0?@curvature<-1:chf("concav_vexity")==1?@curvature>1:abs(@curvature)>chf("concav_vexity")

groupexpression/snippet
    Ends (or First/Last)
    neighbourcount(0,@ptnum)==1

#
# Attribute Expression
#
attribexpression/snippet
    Pass Through
    self

attribexpression/snippet
    Constant Value
    value

attribexpression/snippet
    Multiply by Constant Value
    self * value

attribexpression/snippet
    Add Constant Value
    self + value

attribexpression/snippet
    Random
    rand(@elemnum)

attribexpression/snippet
    Random Scale of Value
    value * float(rand(@elemnum))

attribexpression/snippet
    Random Offset of Value
    value + rand(@elemnum)

attribexpression/snippet
    Second Input's Position
    @opinput1_P

attribexpression/snippet
    Flatten Vector
    set(self.x, 0, self.z)

attribexpression/snippet
    Uniform Parameter on Polyline
    vertexprimindex(0, @vtxnum) / (primvertexcount(0, @primnum) - 1.0)

attribexpression/snippet
    Subtract Center of First Input
    self - getbbox_center(0)

attribexpression/snippet
    Spherify P
    lerp(self,(normalize(self - getbbox_center(0)) * ch("radius")) + getbbox_center(0),ch("Amt"))

attribexpression/snippet
    Spherify N
    @P - getbbox_center(0)

attribexpression/snippet
    Morph to 2nd Input
    lerp(self, point(1,"P",@ptnum),ch("Amt"))

# VEX Channel
#
channelwrangle/snippet
    Lookat
    matrix m1 = lookat(0, @t-chv("lookatvec"), chv("upvec") );

    // Rotate the lookat to point to a different axis.
    int mode = chi("rorder");
    if( mode>=0 && mode<=6 )
        m1 = maketransform( /*trs_order=*/0, /*rot_order=*/mode, /*t=*/0, /*r=*/chv("angle"), /*s=*/1 ) * m1;

    @r = cracktransform(0,0,1,0,m1); // Overwrite only the rotation

channelwrangle/snippet
    Identity
    @t = 0;
    @r = 0;
    @s = 1;

channelwrangle/snippet
    Distance
    chopTRS c0 = c->fetchInput(0);
    chopTRS c1 = c->fetchInput(1);

    // Compute the vector betweem first and second input.
    // and scale it with a radius parm
    vector dt = normalize(c1.t - c0.t)* chf('radius');

    @t = c0.t + dt; // Translation from first input + radius vector 
    @r = c1.r;      // Rotation from second input
    @s = c0.s;      // Scale from first input

attribexpression/snippet
    Line - Archimedean Spiral
    set(ch("radius")*relbbox(@P).y*cos(relbbox(@P).y*ch("turns")*2*$PI),ch("radius")*relbbox(@P).y*sin(relbbox(@P).y*ch("turns")*2*$PI),self.z)

attribexpression/snippet
    Line - Helix
    set(chramp("width",relbbox(@P).y)*ch("radius")*sin(relbbox(@P).y*2*$PI*ch("turns")),ch("height")*relbbox(@P).y,chramp("width",relbbox(@P).y)*ch("radius")*cos(relbbox(@P).y*2*$PI*ch("turns")))

attribexpression/snippet
    Taper
    @P;
    if(chi("axis")==0)
    {
        @P=set(self.x,self.y*chramp("profile",relbbox(@P).x)*ch("mult"),self.z*chramp("profile",relbbox(@P).x)*ch("mult"));
    }
    else
    {
        if(chi("axis")==1)
        {
            @P=set(self.x*chramp("profile",relbbox(@P).y)*ch("mult"),self.y,self.z*chramp("profile",relbbox(@P).y)*ch("mult"));    
        }
        else
        {
            @P=set(self.x*chramp("profile",relbbox(@P).z)*ch("mult"),self.y*chramp("profile",relbbox(@P).z)*ch("mult"),self.z);
        }
    }

attribexpression/snippet
    Droop
    set(@P.x,@P.y - ch("droop")*chramp("effect",fit(length(set(@P.x,0,@P.z)),0,getbbox_size(0),0,1)),@P.z)

attribexpression/snippet
    Melt
    set(@P.x*ch("melt")*chramp("effect",relbbox(@P).y)+@P.x,clamp(@P.y + ch("thickness")*@N.y - ch("melt"),getbbox_min(0).y+ch("thickness")*@N.y,getbbox_max(0).y),@P.z*ch("melt")*chramp("effect",relbbox(@P).y)+@P.z)   

attribexpression/snippet
    Collision Deform
    @P;
    int nearestptid = nearpoint(1,@P);
    vector nearestpt = point(1,"P",nearestptid);
    vector nearestptn = normalize(point(1,"N",nearestptid));
    float dist=length(@P-nearestpt);
    @P = dist<ch("range")?lerp(@P,@P+(@N*ch("n_bias"))+(nearestptn*(1-ch("n_bias"))),ch("deform")*chramp("lip",fit(dist,0,2*ch("range"),0,1))*(1-dist)) : @P

attribexpression/snippet
    Lookat 2nd Input
    (@P - getbbox_center(0)) * lookat(getbbox_center(1),getbbox_center(0)) + getbbox_center(0)   
    
attribexpression/snippet
    Align
    @P;
    int alignaxis = chi("axis");
    float offset = ch("offset");
    if(alignaxis == 0){
        @P.y -= getbbox_min(0).y - offset;
    }
    else if(alignaxis == 1){
        @P.y -= getbbox_max(0).y - offset;
    }
    else if(alignaxis == 2){
        @P.x -= getbbox_min(0).x - offset;
    }
    else if(alignaxis == 3){
        @P.x -= getbbox_max(0).x - offset;
    }
    else if(alignaxis == 4){
        @P.z -= getbbox_min(0).z - offset;
    }
    else {
        @P.z -= getbbox_max(0).z - offset;
    }

attribexpression/snippet
    Stack
    @P;
    int stackaxis=chi("axis");
    float stackoffset=ch("offset");
    @P+=getbbox_center(1);
    if(stackaxis==0){
        @P.x+=getbbox_max(1).x-getbbox_center(1).x-getbbox_min(0).x+stackoffset;
    }
    else if(stackaxis==1){
        @P.y+=getbbox_max(1).y-getbbox_center(1).y-getbbox_min(0).y+stackoffset;
    }
    else{
        @P.z+=getbbox_max(1).z-getbbox_center(1).z-getbbox_min(0).z+stackoffset;
    }    

attribexpression/snippet
    PlanarSymTaper
    @P;
    int plane = chi("TaperPlane");
    float tap = 10*ch("Taper");
    float cent = ch("Centre");
    vector c = getbbox_center(0);
    vector relbbox = relbbox(0,@P);
    
    @P -= c;
    if(plane==0)
        {
        @P.x *= cos(tap*abs(relbbox.y - cent));
        }
    else if(plane==1)
        {
        @P.y *= cos(tap*abs(relbbox.x - cent));
        }
    else if(plane==2)
        {
        @P.x *= cos(tap*abs(relbbox.z - cent));
        }
    else if(plane==3)
        {
        @P.z *= cos(tap*abs(relbbox.x - cent));
        }
    else if(plane==4)
        {
        @P.y *= cos(tap*abs(relbbox.z - cent));
        }
    else
        {
        @P.z *= cos(tap*abs(relbbox.y - cent));
        }
    @P += c;