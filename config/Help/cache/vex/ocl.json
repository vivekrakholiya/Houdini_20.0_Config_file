{"type": "root", "attrs": {}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["OpenCL for VEX users"], "extent": [0, 25]}, {"type": "summary", "indent": 0, "text": ["OpenCL paradigms explained in terms of VEX."], "extent": [25, 77]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Why OpenCL?"], "extent": [77, 95], "body": [{"type": "para", "indent": 0, "text": ["VEX is ideal for most computation needs.  But some types of algorithms\nhave a structure that lend themselves to fast GPU execution.  Since\nVEX can\u2019t run on the GPU, a different language is needed to describe\nyour algorithm."], "extent": [95, 321]}, {"type": "para", "indent": 0, "text": ["OpenCL is a standard kernel language that supports both GPU and CPU\nimplementations.  This ensures your algorithm can run on machines\nlacking a GPU without the need for maintaining two versions."], "extent": [321, 517]}, {"type": "para", "indent": 0, "text": ["A key requirement to gain the benefit of a GPU is to have the data\nstay on the GPU.  If any non-OpenCL nodes process the geometry they\nwill pull the data back to the CPU, often eliminating the performance\nbenefit.  Note in SOPs every SOP must bring the geometry back after it\ncompletes cooking to store in its local cache.  This can be avoided by\nensuring a chain of OpenCL nodes are in a Compiled Block."], "extent": [517, 923]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Why Not OpenCL?"], "extent": [923, 945], "body": [{"type": "para", "indent": 0, "text": ["OpenCL is an even less friendly language than VEX, though experience\nin VEX will make a lot of it familiar.  Its use of pointers means it\nis easy to write unsafe code that might crash your video card driver\nor Houdini.   While developiong you may find yourself in a bad state\nwhere all kernels error on compile - restarting Houdini may be\nnecessary to restore the driver.  Rarely, you may need to restart your\nmachine."], "extent": [945, 1366]}, {"type": "para", "indent": 0, "text": ["GPUs do not have virtual memory, so while normally allocating too much\ndata will cause swapping and slowness, with OpenCL you instead get\nallocation failures and errors."], "extent": [1366, 1537]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax and Language"], "extent": [1537, 1563], "body": [{"type": "para", "indent": 0, "text": ["OpenCL is a C-like language, as is VEX.  Both share the same look -\nsemicolons are required to terminate each line; braces are used to\nenclose blocks, etc."], "extent": [1563, 1721]}, {"type": "para", "indent": 0, "text": ["OpenCL itself follows C99, so online resources for C99 can be referred\nto as well."], "extent": [1721, 1805]}, {"type": "para", "indent": 0, "text": ["There is no foreach() in OpenCL."], "extent": [1805, 1839]}, {"type": "para", "indent": 0, "text": ["Parameters to a function must have a type for each parameter and are\nseparate by commas, not semicolons:"], "extent": [1839, 1945]}, {"type": "para", "indent": 0, "text": ["Vex:"], "extent": [1945, 1950]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nint foo(float a; int b, c)\n{\n    return a + b + c;\n}\n"], "extent": [1950, 2017]}, {"type": "para", "indent": 0, "text": ["OpenCL:"], "extent": [2017, 2026]}, {"lang": "ocl", "type": "pre", "indent": 0, "text": ["\nint foo(float a, int b, int c)\n{\n    return a + b + c;\n}\n"], "extent": [2026, 2097]}, {"type": "para", "indent": 0, "text": ["Parameters in OpenCL are always passed by value.  This means changing\na parameter inside of the function will not affect the passed in\nvalue.  But note that OpenCL has pointers, so changing what is pointed\nto will affect the original value."], "extent": [2097, 2340]}, {"type": "para", "indent": 0, "text": ["While functions can be declared inside of functions in VEX, this is\nnot possible in OpenCL."], "extent": [2340, 2433]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Kernels"], "extent": [2433, 2447], "body": [{"type": "para", "indent": 0, "text": ["Both VEX and OpenCL are kernel languages.  The idea of a kernel\nlanguage is to avoid the usual outer-loop for many algorithms.  If one\nwants to add something to every point, in a traditonal language you\nwould have:"], "extent": [2447, 2664]}, {"lang": "cpp", "type": "pre", "indent": 0, "text": ["\nfor (int i = 0; i < number_of_points; i++)\n{\n    process_point(i);\n}\n"], "extent": [2664, 2747]}, {"type": "para", "indent": 0, "text": ["An explicit outer loop makes it extremely difficult to optimize,\nhowever, as process_point may depend on earlier calls.  By instead\nonly writing process_point, we both have simpler code but something\nthat can be run in parallel easily.   VEX uses this to swiftly process\nmillions of points, and OpenCL uses it to ensure the GPU can\nefficiently run the program."], "extent": [2747, 3110]}, {"type": "para", "indent": 0, "text": ["In a usual VEX Wrangle SOP the process_point() function is invisible.\nYou write the code inside of process_point(), so you might have a\nsnippet like:"], "extent": [3110, 3260]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\n@P += 1;\n"], "extent": [3260, 3283]}, {"type": "para", "indent": 0, "text": ["Behind the scenes the Wrangle nodes will build a wrapper function for\nthe kernel, something like:"], "extent": [3283, 3381]}, {"lang": "vex", "type": "pre", "indent": 0, "text": ["\nvoid process_point(vector _bound_P)\n{\n_bound_P += 1;\n}\n\ncvex dowrangle(export vector P)\n{\n    process_point(P);\n}\n"], "extent": [3381, 3509]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["dowrangle"]}, " kernel is what is passed to the VEX runtime to run\nacross all the points."], "extent": [3509, 3601]}, {"type": "para", "indent": 0, "text": ["In OpenCL nodes there isn\u2019t the same auto-wrapper.  Instead the\nequivalent of ", {"type": "code", "text": ["dowrangle"]}, " must be written as a kernel function."], "extent": [3601, 3730]}, {"type": "para", "indent": 0, "text": ["The equivalent OpenCL code would be:"], "extent": [3730, 3767]}, {"lang": "ocl", "type": "pre", "indent": 0, "text": ["\nkernel void dowrangle(\n                 int P_length,\n                 global float * restrict P\n)\n{\n    int idx = get_global_id(0);\n    if (idx >= P_length)\n        return;\n\n    float3 pos = vload3(idx, P);\n    pos += 1;\n    vstore3(pos, idx, P);\n}\n"], "extent": [3767, 4031]}, {"type": "para", "indent": 0, "text": ["The OpenCL node must be explicitly configured to bind the P point\nattribute for writing."], "extent": [4031, 4122]}, {"type": "para", "indent": 0, "text": ["To minimize the boilerplate and enable direct access to attributes\nwithout having to use ", {"type": "code", "text": ["vload"]}, " or ", {"type": "code", "text": ["vstore"]}, ", the OpenCL nodes also have\nan @-Binding mode.  When this mode is enabled the kernel can be\nspecifed with @KERNEL and the appropriate boilerplate will be\ninjected.   This code then becomes:"], "extent": [4122, 4421]}, {"lang": "ocl", "type": "pre", "indent": 0, "text": ["\n#bind point &P float3\n\n@KERNEL\n{\n    float3 pos = @P;\n    pos += 1;\n    @P.set(pos);\n}\n"], "extent": [4421, 4522]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Run Over"], "extent": [4522, 4538], "body": [{"type": "para", "indent": 0, "text": ["An important component of a VEX wrangle is the ", {"type": "code", "text": ["Run Over"]}, " parameter.\nThis controls what elements the kernel is executed on.  For example,\nwith ", {"type": "code", "text": ["Run Over"]}, " set to points, kernel will run once for each point.\nThe Volume Wrangle by its nature has an implicit run over of Volumes\nand VDBs - it will run the kernel for each voxel."], "extent": [4538, 4865]}, {"type": "para", "indent": 0, "text": ["With OpenCL you also have to specify what the primary target of the\nkernel is.  Note this doesn\u2019t have to be what is written to, it merely\ndefines how many workitems are given to the GPU."], "extent": [4865, 5054]}, {"type": "para", "indent": 0, "text": ["The most straightforward run over modes are the First-Writable modes.\nThese will find the first writable attribute, volume, or vdb, and use\nthat as the template for the execution."], "extent": [5054, 5235]}, {"type": "para", "indent": 0, "text": ["Unlike VEX that can stumble along even when forced to work serially\nwith Run Over Detail; GPUs do not work well with serial execution and\nshould always target many elements."], "extent": [5235, 5410]}, {"type": "para", "indent": 0, "text": ["The equivalent of For Each Number is the Detail Attribute of Worksets.\nInstead of a fixed number, however, it takes a pair of detail array\nattributes on the incoming geometry to create the work items.  This\nallows for very precise control of the GPU\u2019s execution at the cost of\na lot of complexity."], "extent": [5410, 5709]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Dot operator"], "extent": [5709, 5728], "body": [{"type": "para", "indent": 0, "text": ["In VEX you can access components of a vector using the dot operator\n(", {"type": "code", "text": ["."]}, ").  x,y,z, and w can be used, as can r, g, b, a or u, v.   They\ncan be used in conjunction to swizzle a vector, so ", {"type": "code", "text": ["v.zyx"]}, " would\ncreate a three-vector in reverse order."], "extent": [5728, 5971]}, {"type": "para", "indent": 0, "text": ["OpenCL has a similar notation.  It also has .lo and .hi that will\nextract the top or lower half of a vector, and .odd and .even to pull\nout corresponding slices.   Because it can have up to ", {"type": "code", "text": ["float16"]}, ", there\nis also .s notation; .s0 will be the same as .x, and .s01 the same as\n.xy.  To go past 9, a through f or A through F can be used for 10\nthrough 15.   Note OpenCL does not support the .u or .v variants."], "extent": [5971, 6381]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Built-in Functions"], "extent": [6381, 6406], "body": [{"type": "para", "indent": 0, "text": ["Unlike VEX, OpenCL has a very sparse set of built-in functions.\nVEX has a very rich set of operations to do everything from computing\nthe error function to querying points on geometry.  OpenCL\u2019s internal\nfunctions are largely purely mathematical in nature."], "extent": [6406, 6665]}, {"type": "para", "indent": 0, "text": ["Sadly, there is little in the way of built-in matrix support.\nmatrix.h is provided (and included by default in snippets) which\nprovides some methods for doing matrix multiplications."], "extent": [6665, 6849]}, {"type": "para", "indent": 0, "text": ["Note that ", {"type": "code", "text": ["mat3"]}, " is actually 12 floats in size."], "extent": [6849, 6898]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Note"], "extent": [6898, 6904], "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["select"]}, " is in both OpenCL and VEX, but tragically they have\n    different argument orders.  VEX has the conditional first and\n    OpenCL has the conditional last."], "extent": [6904, 7073]}], "container": true}], "container": true}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Matrix Functions"], "extent": [7073, 7098], "body": [{"type": "para", "indent": 0, "text": ["The matrix.h functions of note are:"], "extent": [7098, 7136]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Function "], "role": "th", "extent": [7136, 7148], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Description"], "extent": [7148, 7164]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat2 transpose2(const mat2 a) "], "role": "td", "extent": [7164, 7196], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["a"]}, " transposed."], "extent": [7196, 7223]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3 transpose3(const mat3 a) "], "role": "td", "extent": [7223, 7255], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["a"]}, " transposed."], "extent": [7255, 7282]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat2 mat2mul(const mat2 a, const mat2 b) "], "role": "td", "extent": [7282, 7325], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["a * b"]}], "extent": [7325, 7344]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal2 mat2vecmul(const mat2 a, const fpreal2 b) "], "role": "td", "extent": [7344, 7396], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["b * A"]}], "extent": [7396, 7415]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal squaredNorm2(const mat2 a) "], "role": "td", "extent": [7415, 7451], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return the square of the L2-norm of a 2\u00d72 matrix."], "extent": [7451, 7505]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal squaredNorm3(const mat3 a) "], "role": "td", "extent": [7505, 7541], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return the square of the L2-norm of a 3\u00d73 matrix."], "extent": [7541, 7595]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3add(const mat3 a, const mat3 b, mat3 c) "], "role": "td", "extent": [7595, 7646], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["c = a + b"]}], "extent": [7646, 7662]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3sub(const mat3 a, const mat3 b, mat3 c) "], "role": "td", "extent": [7662, 7713], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["c = a - b"]}], "extent": [7713, 7729]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3zero(mat3 a) "], "role": "td", "extent": [7729, 7748], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["a = 0"]}], "extent": [7748, 7760]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3identity(mat3 a) "], "role": "td", "extent": [7760, 7783], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["a = identity"]}], "extent": [7783, 7802]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3copy(const mat3 a, mat3 b) "], "role": "td", "extent": [7802, 7835], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["b = a"]}], "extent": [7835, 7847]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3load(size_t idx, const global float *a, mat3 m) "], "role": "td", "extent": [7847, 7901], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Load into ", {"type": "code", "text": ["m"]}, " the 9 floats stored starting at ", {"type": "code", "text": ["a[idx*9]"]}, "  This is\n    loaded row-major."], "extent": [7901, 7993]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3store(mat3 in, size_t idx, const global float *data) "], "role": "td", "extent": [7993, 8052], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Store 9 floats sequentially into ", {"type": "code", "text": ["data[idx*9]"]}, " in a row-major\n    manor."], "extent": [8052, 8130]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3fromcols(const fpreal3 c0, const fpreal3 c1, const fpreal3 c2, mat3 m) "], "role": "td", "extent": [8130, 8212], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Create a 3\u00d73 matrix with columns of the specified vectors."], "extent": [8212, 8276]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["mat3 mat3mul(const mat3 a, const mat3 b) "], "role": "td", "extent": [8276, 8319], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["a * b"]}], "extent": [8319, 8338]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal3 mat3vecmul(const mat3 a, const fpreal3 b) "], "role": "td", "extent": [8338, 8390], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["b * A"]}], "extent": [8390, 8409]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal3 mat3Tvecmul(const mat3 a, const fpreal3 b) "], "role": "td", "extent": [8409, 8462], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["b * A^T"]}], "extent": [8462, 8483]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal2 mat3vecmul(const mat3 a, const fpreal3 b) "], "role": "td", "extent": [8483, 8535], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["b * A"]}, ".  Discards third component."], "extent": [8535, 8582]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal2 mat3Tvecmul(const mat3 a, const fpreal3 b) "], "role": "td", "extent": [8582, 8635], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return ", {"type": "code", "text": ["b * A^T"]}, ".  Discards third component."], "extent": [8635, 8684]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void outerprod3(const fpreal3 a, const fpreal3 b, mat3 c) "], "role": "td", "extent": [8684, 8744], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Set c to the outerproduct of a and b."], "extent": [8744, 8786]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3lcombine(const fpreal s, const mat3 a, const fpreal t, const mat3 b, mat3 c) "], "role": "td", "extent": [8786, 8874], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["c = s * a + t * b"]}], "extent": [8874, 8898]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal det3(const mat3 a) "], "role": "td", "extent": [8898, 8926], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return the determinant of ", {"type": "code", "text": ["a"]}], "extent": [8926, 8960]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal3 diag3(const mat3 a) "], "role": "td", "extent": [8960, 8990], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Return diagonal vector of ", {"type": "code", "text": ["a"]}], "extent": [8990, 9024]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal2 mat4vec2mul(const mat4 a, const fpreal2 b) "], "role": "td", "extent": [9024, 9077], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns ", {"type": "code", "text": ["b * A"]}, "."], "extent": [9077, 9098]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal3 mat43vec3mul(const mat4 a, const fpreal3 b) "], "role": "td", "extent": [9098, 9152], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns b * A, assuming fourth component of b is 0."], "extent": [9152, 9208]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal3 mat4vec3mul(const mat4 a, const fpreal3 b) "], "role": "td", "extent": [9208, 9261], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns b * A, assuming fourth component of b is 1."], "extent": [9261, 9317]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal4 mat4vecmul(const mat4 a, const fpreal4 b) "], "role": "td", "extent": [9317, 9369], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns b * A."], "extent": [9369, 9388]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["int mat4invert(fpreal16 *m) "], "role": "td", "extent": [9388, 9418], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Update ", {"type": "code", "text": ["m"]}, " with its inverse.  Returns 0 on success, 1 if singular."], "extent": [9418, 9489]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal mat2det(const mat2 m) "], "role": "td", "extent": [9489, 9520], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Determinant of ", {"type": "code", "text": ["m"]}], "extent": [9520, 9543]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal mat2inv(const mat2 m, mat2 *minvvout) "], "role": "td", "extent": [9543, 9590], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets minvout to the inverse of m.  Returns the determinant."], "extent": [9590, 9654]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal mat3inv(const mat3 m, mat3 minvout) "], "role": "td", "extent": [9654, 9699], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets minvout to the inverse of m.  Returns the determinant."], "extent": [9699, 9763]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3scale(mat3 mout, const mat3 m, fpreal scale) "], "role": "td", "extent": [9763, 9819], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["mout = m * scale"]}], "extent": [9819, 9842]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["void mat3lincomb2(mat3 mout, const mat3 m1, fpreal scale1, const mat3 m2, fpreal scale2) "], "role": "td", "extent": [9842, 9933], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": [{"type": "code", "text": ["mout = m1 * scale1 + m2 * scale2"]}], "extent": [9933, 9973]}]}], "divider": false}]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Precision"], "extent": [9973, 9989], "body": [{"type": "para", "indent": 0, "text": ["VEX has a single global precison it executes in.  A ", {"type": "code", "text": ["float"]}, " is 32-bits\nin 32-bit mode and 64-bit in 64-bit mode.   Thus there is no\ndistinction of ", {"type": "code", "text": ["double"]}, " vs ", {"type": "code", "text": ["float"]}, "."], "extent": [9989, 10159]}, {"type": "para", "indent": 0, "text": ["OpenCL has fixed precision.  However it is often the case that one\nwants to write code that will switch precision on demand, as 32-bit is\nmuch faster to compute; but some problems will need 64-bit."], "extent": [10159, 10358]}, {"type": "para", "indent": 0, "text": ["The built-in OpenCL types have a specific precision.  We have added\ntwo new types, ", {"type": "code", "text": ["fpreal"]}, " and ", {"type": "code", "text": ["exint"]}, " which have a precision that can\ndepend on the node or incoming geometry, allowing code to be written\nonce but work in several precisions."], "extent": [10358, 10601]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Name "], "role": "th", "extent": [10601, 10609], "container": true}, {"type": "cell", "indent": 4, "text": ["Precision "], "role": "th", "extent": [10609, 10626], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Type"], "extent": [10626, 10639]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["half "], "role": "td", "extent": [10639, 10646], "container": true}, {"type": "cell", "indent": 4, "text": ["16 "], "role": "td", "extent": [10646, 10655], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Float"], "extent": [10655, 10669]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["float "], "role": "td", "extent": [10669, 10677], "container": true}, {"type": "cell", "indent": 4, "text": ["32 "], "role": "td", "extent": [10677, 10686], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Float"], "extent": [10686, 10700]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["double "], "role": "td", "extent": [10700, 10709], "container": true}, {"type": "cell", "indent": 4, "text": ["64 "], "role": "td", "extent": [10709, 10718], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Float"], "extent": [10718, 10732]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fpreal "], "role": "td", "extent": [10732, 10741], "container": true}, {"type": "cell", "indent": 4, "text": ["Variable "], "role": "td", "extent": [10741, 10756], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Float"], "extent": [10756, 10770]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["short "], "role": "td", "extent": [10770, 10778], "container": true}, {"type": "cell", "indent": 4, "text": ["16 "], "role": "td", "extent": [10778, 10787], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer"], "extent": [10787, 10803]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["int "], "role": "td", "extent": [10803, 10809], "container": true}, {"type": "cell", "indent": 4, "text": ["32 "], "role": "td", "extent": [10809, 10818], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer"], "extent": [10818, 10834]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["long "], "role": "td", "extent": [10834, 10841], "container": true}, {"type": "cell", "indent": 4, "text": ["64 "], "role": "td", "extent": [10841, 10850], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer"], "extent": [10850, 10866]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["exint "], "role": "td", "extent": [10866, 10874], "container": true}, {"type": "cell", "indent": 4, "text": ["Variable "], "role": "td", "extent": [10874, 10889], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer"], "extent": [10889, 10906]}]}], "divider": false}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Types"], "extent": [10906, 10918], "body": [{"type": "para", "indent": 0, "text": ["OpenCL and VEX have similar basic types but with different names.  The\n", {"type": "code", "text": ["mat2/3/4"]}, " types are defined in matrix.h.  ", {"type": "code", "text": ["float"]}, " below could be\nreplaced by any of the float precisions (half, float, double, and\nfpreal), as can ", {"type": "code", "text": ["int"]}, "."], "extent": [10918, 11146]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["VEX "], "role": "th", "extent": [11146, 11153], "container": true}, {"type": "cell", "indent": 4, "text": ["OpenCL "], "role": "th", "extent": [11153, 11167], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Type"], "extent": [11167, 11180]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["int "], "role": "td", "extent": [11180, 11186], "container": true}, {"type": "cell", "indent": 4, "text": ["int "], "role": "td", "extent": [11186, 11196], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer value"], "extent": [11196, 11218]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["--"]}, " "], "role": "td", "extent": [11218, 11225], "container": true}, {"type": "cell", "indent": 4, "text": ["int2/3/4/8/16 "], "role": "td", "extent": [11225, 11245], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Integer vector of the given number of components."], "extent": [11245, 11303]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["float "], "role": "td", "extent": [11303, 11311], "container": true}, {"type": "cell", "indent": 4, "text": ["float "], "role": "td", "extent": [11311, 11323], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Float value"], "extent": [11323, 11343]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["vector2 "], "role": "td", "extent": [11343, 11353], "container": true}, {"type": "cell", "indent": 4, "text": ["float2 "], "role": "td", "extent": [11353, 11366], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Two component vector"], "extent": [11366, 11395]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["vector "], "role": "td", "extent": [11395, 11404], "container": true}, {"type": "cell", "indent": 4, "text": ["float3 "], "role": "td", "extent": [11404, 11417], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Three component vector.  Note that in OpenCL this is laid out\n        in memory with four floats, so care has to be taken if used in\n        a structure."], "extent": [11417, 11579]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["vector4 "], "role": "td", "extent": [11579, 11589], "container": true}, {"type": "cell", "indent": 4, "text": ["float4 "], "role": "td", "extent": [11589, 11602], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Four component vector."], "extent": [11602, 11633]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["--"]}, " "], "role": "td", "extent": [11633, 11640], "container": true}, {"type": "cell", "indent": 4, "text": ["float8/16 "], "role": "td", "extent": [11640, 11656], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["OpenCL also has native 8 and 16 component vectors."], "extent": [11656, 11715]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["matrix2 "], "role": "td", "extent": [11715, 11725], "container": true}, {"type": "cell", "indent": 4, "text": ["float4, mat2 "], "role": "td", "extent": [11725, 11744], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["A float4 is the same size as a matrix2, but we've defined a\n        mat2 to make the semantics more clear and provide some utility\n        functions."], "extent": [11744, 11902]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["matrix3 "], "role": "td", "extent": [11902, 11912], "container": true}, {"type": "cell", "indent": 4, "text": ["mat3 "], "role": "td", "extent": [11912, 11923], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["There is no native 9-element type.  The mat3 we have defined\n        is actually a 12-element type, so care has to be done to move\n        it to or from memory."], "extent": [11923, 12092]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["matrix "], "role": "td", "extent": [12092, 12101], "container": true}, {"type": "cell", "indent": 4, "text": ["float16, mat4 "], "role": "td", "extent": [12101, 12121], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["A float16 is the same size as a matrix, but we've defined a\n        mat4 to make the semantics clear and provide some utility\n        functions."], "extent": [12121, 12274]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["string "], "role": "td", "extent": [12274, 12283], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["--"]}, " "], "role": "td", "extent": [12283, 12294], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["You can define string literals for things like printf() in\n        OpenCL, but as this is on the GPU there are many oddities, so\n        these are not the same as the ", {"type": "code", "text": ["const char *"]}, " you may expect\n        from other C languages."], "extent": [12294, 12531]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["dict "], "role": "td", "extent": [12531, 12538], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["--"]}, " "], "role": "td", "extent": [12538, 12549], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["Dictionaries aren\u2019t supported in OpenCL."], "extent": [12549, 12598]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["int[]"]}, ", ", {"type": "code", "text": ["float[]"]}, " "], "role": "td", "extent": [12598, 12619], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["int *"]}, ", ", {"type": "code", "text": ["float *"]}, " "], "role": "td", "extent": [12619, 12644], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 8, "text": ["VEX has an array type which can grow and shrink dynamically.\n        In OpenCL, pointers can be used to a similar effect, but\n        cannot change dynamically."], "extent": [12644, 12815]}]}], "divider": false}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Binding and Prototypes"], "extent": [12815, 12844], "body": [{"type": "para", "indent": 0, "text": ["VEX wrangles and snippets will usually auto-bind attributes when the @\nsyntax is used to refer to them.  For complicated snippets, the\nEnforce Prototypes can be turned on that requires the binding to be\nexplicitly listed before it is used."], "extent": [12844, 13086]}, {"type": "para", "indent": 0, "text": ["Because of the auto-binding, VEX\u2019s @ syntax has a prefix to specify\nthe type where it isn\u2019t implied."], "extent": [13086, 13188]}, {"type": "para", "indent": 0, "text": ["OpenCL has no auto-binding, and also no type prefixes.  Instead any @\nbinding must be explicitly provided either as a parameter in the\nBindings tab of the node; or as a ", {"type": "code", "text": ["#bind"]}, " directive in the snippet."], "extent": [13188, 13392]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["#bind"]}, " directive provides a way to specify the same information\nas in the Bindings parameters in a concise line.  Where the same @\nbinding is controlled both by the ", {"type": "code", "text": ["#bind"]}, " and a binding parameter, it\nis the binding parameter that is used."], "extent": [13392, 13638]}, {"type": "para", "indent": 0, "text": ["The basic format of the ", {"type": "code", "text": ["#bind"]}, " directive is"], "extent": [13638, 13683]}, {"lang": "ocl", "type": "pre", "indent": 0, "text": ["\n//    type name   flags...\n#bind parm foobar read write\n"], "extent": [13683, 13753]}, {"type": "para", "indent": 0, "text": ["The type is what to bind to.  The name is the token used in the @\nstatements to refer to this binding.  By default it will match the\nattribute name, but a different attribute can be selected using the\nflags.  (This is required if you have two attributes of the same name\nbound, you will need different names for them for the @ to\ndisambiguate)"], "extent": [13753, 14099]}, {"type": "para", "indent": 0, "text": ["Flags are a space separated list of flags."], "extent": [14099, 14143]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Binding Name Decorations"], "extent": [14143, 14176], "body": [{"type": "para", "indent": 0, "text": ["The name can be decorated. Decorations can go before or after the\nname."], "extent": [14176, 14250]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Decoration "], "role": "th", "extent": [14250, 14264], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Implied Flag"], "extent": [14264, 14281]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["&"]}, " "], "role": "td", "extent": [14281, 14287], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["write"], "extent": [14287, 14297]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["?"]}, " "], "role": "td", "extent": [14297, 14303], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["opt"], "extent": [14303, 14311]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["!"]}, " "], "role": "td", "extent": [14311, 14317], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["noread"], "extent": [14317, 14329]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Binding Types"], "extent": [14329, 14351], "body": [{"type": "para", "indent": 0, "text": ["Valid bindings words are listed here.  Note the corresponding binding\nin the multiparm can provide more details of how these work."], "extent": [14351, 14484]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Binding "], "role": "th", "extent": [14484, 14495], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Type"], "extent": [14495, 14504]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["parm "], "role": "td", "extent": [14504, 14511], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Matches integer, float, float vec style bindings.  A flag of\n    ", {"type": "code", "text": ["float"]}, ", ", {"type": "code", "text": ["float3"]}, ", ", {"type": "code", "text": ["int"]}, ", etc, will specify which type.  This is\n    used to control the snippet with a parameter constant across all\n    work items."], "extent": [14511, 14730]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["point/prim/primitive/global/detail/vertex "], "role": "td", "extent": [14730, 14774], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds a geometry attribute of this class."], "extent": [14774, 14820]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["ramp "], "role": "td", "extent": [14820, 14827], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds a ramp.  The flag of ", {"type": "code", "text": ["float"]}, " or ", {"type": "code", "text": ["float3"]}, " controls if it is a\n    scalar or vector ramp."], "extent": [14827, 14925]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["volume "], "role": "td", "extent": [14925, 14934], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds a volume primitive in a geometry."], "extent": [14934, 14978]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["vdb "], "role": "td", "extent": [14978, 14984], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds a VDB primitive in a geometry."], "extent": [14984, 15025]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["option "], "role": "td", "extent": [15025, 15034], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds a DOP Option in DOPs."], "extent": [15034, 15066]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["sfield/vfield/mfield/scalarfield/vectorfield/matrixfield "], "role": "td", "extent": [15066, 15125], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Binds to a DOP field of the provided type."], "extent": [15125, 15173]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Type Flag"], "extent": [15173, 15191], "body": [{"type": "para", "indent": 0, "text": ["One type of flag is to use an OpenCL type as the flag, such as ", {"type": "code", "text": ["float"]}, "\nor ", {"type": "code", "text": ["float2"]}, ".  This then specifies the vector size, precision, etc, of\nthe binding.   ", {"type": "code", "text": ["float[]"]}, " can be used to specify a binding to an array\nattribute.   In additon, ", {"type": "code", "text": ["float?"]}, " and ", {"type": "code", "text": ["int?"]}, " can be used to bind to\nattributes of arbitrary size.  The ", {"type": "code", "text": ["tuplesize"]}, " method can be used to\nsee what the actual bound size was."], "extent": [15191, 15577]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Access Flags"], "extent": [15577, 15598], "body": [{"type": "para", "indent": 0, "text": ["Access flags control how the source attribute is bound to the kernel."], "extent": [15598, 15670]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Flag "], "role": "th", "extent": [15670, 15678], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [15678, 15690]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["read / noread "], "role": "td", "extent": [15690, 15706], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to read."], "extent": [15706, 15729]}, {"type": "para", "indent": 4, "text": ["If a binding is readable it will have its OpenCL buffer\n    initialized from its original value.  If you do not mark it as\n    readable, it is important you overwrite it as otherwise arbitrary\n    data will be present."], "extent": [15729, 15952]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["write / nowrite "], "role": "td", "extent": [15952, 15970], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to nowrite."], "extent": [15970, 15996]}, {"type": "para", "indent": 4, "text": ["A binding not marked writable will not be written back to the CPU\n    as it will be assumed to be unchanged.  Note you may still\n    actually write to it if you try hard enough.  Doing so will result\n    in undefined behaviour."], "extent": [15996, 16228]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["opt / noopt "], "role": "td", "extent": [16228, 16242], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to noopt."], "extent": [16242, 16266]}, {"type": "para", "indent": 4, "text": ["An optional binding doesn\u2019t need to exist on the original\n    geometry.  The macro define HAS_name will be defined if the\n    binding does exist, allowing one to have different code paths.\n    Alternatively, if the def flag is present, the missing binding\n    will be replaced by a single default value."], "extent": [16266, 16575]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["def / nodef "], "role": "td", "extent": [16575, 16589], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to def."], "extent": [16589, 16611]}, {"type": "para", "indent": 4, "text": ["If an optional binding isn\u2019t present, will instead bind a\n    parameter in the same place.  For example, if one binds the point\n    attribute ", {"type": "code", "text": ["mass"]}, " optionally and mass isn\u2019t present, a float\n    parameter ", {"type": "code", "text": ["mass"]}, " will be bound in its place.  This lets code use\n    @mass to refer to the value and switch between the default value\n    or the geometry value without any code changes or use of HAS_mass\n    #ifdefs."], "extent": [16611, 17029]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Target Flags"], "extent": [17029, 17050], "body": [{"type": "para", "indent": 0, "text": ["Binding target flags control exactly what is used for the source of\nthe binding.  The name used for the @ is always the binding name,\nwhich often forms the default for what is bound, but these allow finer\ncontrol."], "extent": [17050, 17266]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Flag "], "role": "th", "extent": [17266, 17274], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [17274, 17286]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["val=# "], "role": "td", "extent": [17286, 17294], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to 0."], "extent": [17294, 17314]}, {"type": "para", "indent": 4, "text": ["Set the default value for the parmameter, volume, or vdb.\n    If it is a vector binding and a single scalar is provided, it is\n    repeated, so ", {"type": "code", "text": ["val=1"]}, " on a vector will use a default value of ", {"type": "code", "text": ["(1,\n    1, 1)"]}, ".  Vector values can be specified by using braces, so\n    ", {"type": "code", "text": ["val={1, 2, 3}"]}, " will use the corresponding default value."], "extent": [17314, 17641]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["name=SSS "], "role": "td", "extent": [17641, 17652], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to the binding name."], "extent": [17652, 17687]}, {"type": "para", "indent": 4, "text": ["The name of the attribute, volume, or VDB to bind to."], "extent": [17687, 17745]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["input=# "], "role": "td", "extent": [17745, 17755], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to 0."], "extent": [17755, 17775]}, {"type": "para", "indent": 4, "text": ["In SOPs, the input to bind to.  Only the first input can be\n    written to."], "extent": [17775, 17855]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["geo=SSS "], "role": "td", "extent": [17855, 17865], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Defaults to Geometry."], "extent": [17865, 17892]}, {"type": "para", "indent": 4, "text": ["In DOPs, the simulation geometry to bind to, relative to the root of the\n    current simulation object."], "extent": [17892, 18002]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Feature Flags"], "extent": [18002, 18024], "body": [{"type": "para", "indent": 0, "text": ["In addition there are general feature flags that are often specific to\ncertain binding types.  These may be needed to enable certain methods\non the binding as well.  These correspond to toggles in the Bindings\nmultiparm of either the OpenCL SOP or DOP, so more details can be\nfound there as well."], "extent": [18024, 18323]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Flag "], "role": "th", "extent": [18323, 18331], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [18331, 18343]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["fieldoffsets / nofieldoffsets "], "role": "td", "extent": [18343, 18375], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default fieldoffsets."], "extent": [18375, 18402]}, {"type": "para", "indent": 4, "text": ["For Field Bindings in DOPs, enable the offset parameters for this\n    field."], "extent": [18402, 18483]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["forcealign / noforcealign "], "role": "td", "extent": [18483, 18511], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default forcealign."], "extent": [18511, 18536]}, {"type": "para", "indent": 4, "text": ["Requires all the fields or volumes to have the same resolution.  This\n    lets the code be simpler and allow assumptions about samples\n    lining up.  "], "extent": [18536, 18693]}, {"type": "para", "indent": 4, "text": ["Note that the first writeable field or volume (the one\n    being iterated over\u2026) should not be forcealigned, so its default\n    is noforcealign."], "extent": [18693, 18844]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["resolution / noresolution "], "role": "td", "extent": [18844, 18872], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default noresolution."], "extent": [18872, 18899]}, {"type": "para", "indent": 4, "text": ["Include the resolution of the field or volume.  This is required\n    for bounds checking, but only usually required for the first\n    volume if the others are aligned."], "extent": [18899, 19072]}, {"type": "para", "indent": 4, "text": ["The first writeable volume has a default of resolution."], "extent": [19072, 19132]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["voxelsize / novoxelsize "], "role": "td", "extent": [19132, 19158], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default novoxelsize."], "extent": [19158, 19184]}, {"type": "para", "indent": 4, "text": ["Include the size of the voxels of the volume."], "extent": [19184, 19234]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["xformtoworld / noxformtoworld "], "role": "td", "extent": [19234, 19266], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default noxformtoworld."], "extent": [19266, 19295]}, {"type": "para", "indent": 4, "text": ["Include the transform from index space to geometry (SOP) space."], "extent": [19295, 19363]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["xformtovoxel / noxformtovoxel "], "role": "td", "extent": [19363, 19395], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Default noxformtovoxel."], "extent": [19395, 19424]}, {"type": "para", "indent": 4, "text": ["Include the transform from geometry (SOP) space to index space."], "extent": [19424, 19494]}]}], "divider": false}]}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Spare Parameter Creation"], "extent": [19494, 19525], "body": [{"type": "para", "indent": 0, "text": ["In VEX you can instrument your function by including ", {"type": "code", "text": ["ch(\"myparm\")"]}, "\ndirectly in the code.   Then the generate-parameter button can be\npressed and a spare parameter ", {"type": "code", "text": ["myparm"]}, " will be created that the VEX\ncode will read at execution time."], "extent": [19525, 19763]}, {"type": "para", "indent": 0, "text": ["OpenCL, running on the GPU, cannot have the equivalent of\n", {"type": "code", "text": ["ch(\"myparm\")"]}, " as everything must be explicitly bound.  Thus the\nequivalent is to have a ", {"type": "code", "text": ["#bind"]}, " directive such as ", {"type": "code", "text": ["#bind parm myparm\nfloat"]}, "."], "extent": [19763, 19964]}, {"type": "para", "indent": 0, "text": ["To actually control the value that is bound, you can manually add\n", {"type": "code", "text": ["myparm"]}, " as a binding in the Bindings tab.  By setting it to float\ntype, the float value can be animated there to control what is passed\nto OpenCL."], "extent": [19964, 20179]}, {"type": "para", "indent": 0, "text": ["To make things easier, the generate-parameter button on the OpenCL\nnode will parse all the ", {"type": "code", "text": ["#bind"]}, " directives and create a corresponding\nentry in the Bindings page, but also create a spare parameter next to\nthe code that drives the multiparm value.  It is important to note the\nresulting spare parameter is not directly read by the OpenCL code - it\nis driving the value of the multiparm, and that mulitparm is then\nbound to the kernel before execution."], "extent": [20179, 20634]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Topology and Group Binding Names"], "extent": [20634, 20673], "body": [{"type": "para", "indent": 0, "text": ["Vex has several magic names that affect the binding process.\n", {"type": "code", "text": ["@group_foo"]}, " will bind to the group ", {"type": "code", "text": ["foo"]}, ", for example, and\n", {"type": "code", "text": ["@opinput1_P"]}, " will bind to ", {"type": "code", "text": ["P"]}, " on the second input."], "extent": [20673, 20848]}, {"type": "para", "indent": 0, "text": ["OpenCL also has similar options.   Binding to the attribute\n", {"type": "code", "text": ["group:foo"]}, " will bind to the group ", {"type": "code", "text": ["foo"]}, ".  Note the binding has to be\nof integer type."], "extent": [20848, 20996]}, {"type": "para", "indent": 0, "text": ["Several topology attributes are also supported using the ", {"type": "code", "text": ["topo:"]}, "\nprefix.  These must be bound to the correct class and type.  These are\nall read-only.  Where possible they closely match the corresponding\nVEX functions."], "extent": [20996, 21216]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Topology Name "], "role": "th", "extent": [21216, 21233], "container": true}, {"type": "cell", "indent": 4, "text": ["Class "], "role": "th", "extent": [21233, 21246], "container": true}, {"type": "cell", "indent": 8, "text": ["Type "], "role": "th", "extent": [21246, 21262], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Meaning"], "extent": [21262, 21282]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:primpoints "], "role": "td", "extent": [21282, 21300], "container": true}, {"type": "cell", "indent": 4, "text": ["prim "], "role": "td", "extent": [21300, 21311], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int[]"]}, " "], "role": "td", "extent": [21311, 21329], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by primitive number, stores all the points indices\n            belonging to that primitive."], "extent": [21329, 21441]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:primvertices "], "role": "td", "extent": [21441, 21461], "container": true}, {"type": "cell", "indent": 4, "text": ["prim "], "role": "td", "extent": [21461, 21472], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int[]"]}, " "], "role": "td", "extent": [21472, 21490], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by primitive number, stores all the vertex indices\n            belonging to that primitive."], "extent": [21490, 21602]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:primvertexcount "], "role": "td", "extent": [21602, 21625], "container": true}, {"type": "cell", "indent": 4, "text": ["prim "], "role": "td", "extent": [21625, 21636], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [21636, 21652], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by primitive number, stores the number of\n            vertices on that primitive."], "extent": [21652, 21754]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:pointprims "], "role": "td", "extent": [21754, 21772], "container": true}, {"type": "cell", "indent": 4, "text": ["point "], "role": "td", "extent": [21772, 21784], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int[]"]}, " "], "role": "td", "extent": [21784, 21802], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by point number, stores the primitive indices that\n            refer to that point."], "extent": [21802, 21906]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:pointvertices "], "role": "td", "extent": [21906, 21927], "container": true}, {"type": "cell", "indent": 4, "text": ["point "], "role": "td", "extent": [21927, 21939], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int[]"]}, " "], "role": "td", "extent": [21939, 21957], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by point number, stores the vertex indices that\n            refer to that point."], "extent": [21957, 22058]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:pointneighbours "], "role": "td", "extent": [22058, 22081], "container": true}, {"type": "cell", "indent": 4, "text": ["point "], "role": "td", "extent": [22081, 22093], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int[]"]}, " "], "role": "td", "extent": [22093, 22111], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by point number, stores the point indices of the\n            ring neighbours of the point; as per the ", {"type": "code", "text": ["neighbours"]}, " VEX\n            function."], "extent": [22111, 22272]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:vertexpoint "], "role": "td", "extent": [22272, 22291], "container": true}, {"type": "cell", "indent": 4, "text": ["vertex "], "role": "td", "extent": [22291, 22304], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [22304, 22320], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by vertex number, stores the point index that the\n            vertex refers to."], "extent": [22320, 22420]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:vertexprim "], "role": "td", "extent": [22420, 22438], "container": true}, {"type": "cell", "indent": 4, "text": ["vertex "], "role": "td", "extent": [22438, 22451], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [22451, 22467], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by vertex number, stores the primitive index that the\n            vertex is owned by."], "extent": [22467, 22573]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["topo:vertexprimindex "], "role": "td", "extent": [22573, 22596], "container": true}, {"type": "cell", "indent": 4, "text": ["vertex "], "role": "td", "extent": [22596, 22609], "container": true}, {"type": "cell", "indent": 8, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [22609, 22625], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Indexed by vertex number, stores where in the primitive\n            this vertex belongs."], "extent": [22625, 22727]}]}], "divider": false}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Global Bindings"], "extent": [22727, 22749], "body": [{"type": "para", "indent": 0, "text": ["VEX has various default bindings that are presented in many wrangles.\nOpenCL likewise has some, but while VEX will often bind these\njust-in-time if they show up in your code, OpenCL often requires an\nexplicit feature flag to be set on the node to enable the binding."], "extent": [22749, 23018]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Binding "], "role": "th", "extent": [23018, 23029], "container": true}, {"type": "cell", "indent": 4, "text": ["Type "], "role": "th", "extent": [23029, 23041], "container": true}, {"type": "cell", "indent": 8, "text": ["Validity "], "role": "th", "extent": [23041, 23061], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Meaning"], "extent": [23061, 23081]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@ix"]}, ", ", {"type": "code", "text": ["@iy"]}, ", ", {"type": "code", "text": ["@iz"]}, " "], "role": "td", "extent": [23081, 23103], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [23103, 23115], "container": true}, {"type": "cell", "indent": 8, "text": ["Running over volumes, VDBs, or fields. "], "role": "td", "extent": [23115, 23164], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["The currently processed voxel integer index."], "extent": [23164, 23221]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@elemnum"]}, " "], "role": "td", "extent": [23221, 23234], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [23234, 23246], "container": true}, {"type": "cell", "indent": 8, "text": ["Running over volumes, attributes, or VDBs.  Running over fields where the fields are aligned. "], "role": "td", "extent": [23246, 23350], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["An integer index representing the currently processed element.\n            Note for VDBs this will vary with the topology."], "extent": [23350, 23485]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@P"]}, " "], "role": "td", "extent": [23485, 23492], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["float3"]}, " "], "role": "td", "extent": [23492, 23507], "container": true}, {"type": "cell", "indent": 8, "text": ["Running over fields. "], "role": "td", "extent": [23507, 23538], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["The current DOP/Model space of the processed voxel."], "extent": [23538, 23602]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@Time"]}, " "], "role": "td", "extent": [23602, 23612], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["float"]}, " "], "role": "td", "extent": [23612, 23626], "container": true}, {"type": "cell", "indent": 8, "text": ["Include Time specified on node "], "role": "td", "extent": [23626, 23667], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["Current time in seconds.  Makes the node time dependent."], "extent": [23667, 23736]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@TimeInc"]}, " "], "role": "td", "extent": [23736, 23749], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["float"]}, " "], "role": "td", "extent": [23749, 23763], "container": true}, {"type": "cell", "indent": 8, "text": ["Include Timestep specified on node "], "role": "td", "extent": [23763, 23808], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["The current timestep, usually ", {"type": "code", "text": ["1/$FPS"]}, " in SOPs, but the\n            current simulation step size if in DOPs."], "extent": [23808, 23929]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@SimFrame"]}, " "], "role": "td", "extent": [23929, 23943], "container": true}, {"type": "cell", "indent": 4, "text": [{"type": "code", "text": ["int"]}, " "], "role": "td", "extent": [23943, 23955], "container": true}, {"type": "cell", "indent": 8, "text": ["Include SImulation Frame specified on node "], "role": "td", "extent": [23955, 24008], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 12, "text": ["The current simulation frame, ", {"type": "code", "text": ["$SF"]}, "."], "extent": [24008, 24059]}]}], "divider": false}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["@-Binding Methods"], "extent": [24059, 24083], "body": [{"type": "para", "indent": 0, "text": ["In VEX an @ binding is the actual value.  @P will be the\nvector of the current position and be of type vector.  Writing to the\ncurrent position is done by simply assigning to @P.   To work with\nposition on points other than the current point, the ", {"type": "code", "text": ["point"]}, " and\n", {"type": "code", "text": ["setpointattrib"]}, " functions are used."], "extent": [24083, 24381]}, {"type": "para", "indent": 0, "text": ["In VEX the @ binding is effectively a local variable - writing or\nreading to it is the same as any variable.  In OpenCL, the @ binding\nmay represent more computation, so it is often useful to copy it into\na local variable if it is to be used extensively."], "extent": [24381, 24637]}, {"type": "para", "indent": 0, "text": ["With OpenCL reading and writing to arbitrary attributes such as done\nin the ", {"type": "code", "text": ["point"]}, " and ", {"type": "code", "text": ["setpointattrib"]}, " functions is not possible as all\ndata has to be explicitly bound.  But this also means that when the\nposition attribute is bound with @P, all of the position data is\navailable for reading.  Access to the full data is provided by adding\nvarious methods to the @ binding.   ", {"type": "code", "text": ["@P.getAt(53)"]}, " will read the point\nwith index 53, for example.   These methods include bounds checking to\nensure that your kernel does not fail catastrophically due to\nprogramming errors, much like the ", {"type": "code", "text": ["point"]}, " and ", {"type": "code", "text": ["setpointattrib"]}, "\nmethods."], "extent": [24637, 25255]}, {"type": "para", "indent": 0, "text": ["The ", {"type": "code", "text": ["setpointattrib"]}, " functions in VEX are designed to be thread-safe\nand always operate the same.  The corresponding ", {"type": "code", "text": ["setAt"]}, " functions in\nOpenCL have no such guarantee, it is important you are careful not to\nhave two work items write to the same point."], "extent": [25255, 25509]}, {"type": "para", "indent": 0, "text": ["What methods are available depend on the type of the binding, the type\nof data it is bound to, whether the data is readable or writable, and\nwhether the data is aligned to the current work item.   In particular,\nthe last point is that you can only refer to ", {"type": "code", "text": ["@P"]}, " as a raw value if\nthe position attribute, or a matching attribute, is being run over.\nOtherwise which point you want must be specified."], "extent": [25509, 25908]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Parameter Binding Methods"], "extent": [25908, 25942], "body": [{"type": "para", "indent": 0, "text": ["A ", {"type": "code", "text": ["parm"]}, " binding is merely the value itself.  Thus there are no\nmethods as ", {"type": "code", "text": ["@name"]}, " will refer to the actual value."], "extent": [25942, 26059]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Ramp Binding Methods"], "extent": [26059, 26088], "body": [{"type": "para", "indent": 0, "text": ["A ramp in OpenCL is always a 1d array of floats that is interpolated\nto get the ramp values.  The size of the ramp is specified in the\nbinding.   The provided methods ensure one does not have to worry\nabout the nuances of the data layout, however."], "extent": [26088, 26338]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [26338, 26348], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [26348, 26360]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.data"]}, " "], "role": "td", "extent": [26360, 26375], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The float array of the actual ramp data."], "extent": [26375, 26420]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.len"]}, " "], "role": "td", "extent": [26420, 26434], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The size of the ramp."], "extent": [26434, 26460]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name(float)"]}, ", ", {"type": "code", "text": ["@name.getAt(float)"]}, " "], "role": "td", "extent": [26460, 26499], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Look up the value of the ramp at the 0..1 position requested,\n    interpolating between the samples."], "extent": [26499, 26605]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Field Binding Methods"], "extent": [26605, 26635], "body": [{"type": "para", "indent": 0, "text": ["The vector and matrix fields have ", {"type": "code", "text": ["_x"]}, " and ", {"type": "code", "text": ["_xx"]}, " suffixes to refer to\nthe different components.   So if the binding name is ", {"type": "code", "text": ["name"]}, ", a vector\nfield will have ", {"type": "code", "text": ["@name.stride_x_y"]}, " for the ", {"type": "code", "text": ["y"]}, " stride of the ", {"type": "code", "text": ["x"]}, "\nfield of the vector field."], "extent": [26635, 26870]}, {"type": "para", "indent": 0, "text": ["A field is aligned if it has matching resolution and transform to the\nfield being run over."], "extent": [26870, 26963]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [26963, 26973], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [26973, 26985]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.data"]}, " "], "role": "td", "extent": [26985, 27000], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The raw float data of the field."], "extent": [27000, 27037]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.stride_x/y/z/offset"]}, " "], "role": "td", "extent": [27037, 27067], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The stride of a step in the x, y, and z axes of the data.  The\n    offset is an offset from the data to the 0,0,0 voxel."], "extent": [27067, 27192]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.x/y/zres"]}, " "], "role": "td", "extent": [27192, 27211], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The x, y, or z resolution of the field."], "extent": [27211, 27255]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name"]}, ", ", {"type": "code", "text": ["@name.get"]}, " "], "role": "td", "extent": [27255, 27278], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The current processed value.   Valid if aligned."], "extent": [27278, 27331]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.getAt(x,y,z)"]}, " "], "role": "td", "extent": [27331, 27354], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The the voxel at index location x, y, z."], "extent": [27354, 27399]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.set(val)"]}, " "], "role": "td", "extent": [27399, 27418], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Set the currently processed voxel to val.  Valid if aligned."], "extent": [27418, 27483]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.setAt(x, y, z, val)"]}, " "], "role": "td", "extent": [27483, 27513], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Set the voxel at (x, y, z) to val."], "extent": [27513, 27552]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.sample(xyz)"]}, " "], "role": "td", "extent": [27552, 27574], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Evaluate the field in index space at ", {"type": "code", "text": ["float3 xyz"]}, "."], "extent": [27574, 27630]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Attribute Binding Methods"], "extent": [27630, 27664], "body": [{"type": "para", "indent": 0, "text": ["Attributes bind to geometry attributes, so may be point, primitive,\nvertex, or detail.   These include groups, which have a ", {"type": "code", "text": ["group:"]}, "\nprefix and topology that have a ", {"type": "code", "text": ["topo:"]}, " prefix."], "extent": [27664, 27847]}, {"type": "para", "indent": 0, "text": ["An attribute has a matching index if it the kernel is running over\nattributes and the attribute is the same class and size as the\nattribute that is being run over."], "extent": [27847, 28012]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [28012, 28022], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [28022, 28034]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.data"]}, " "], "role": "td", "extent": [28034, 28049], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The raw attribute data.  All the element data is flattened into a\n    single array with no holes or pages.  For array attributes, the\n    array data is stored contiguously."], "extent": [28049, 28227]}, {"type": "para", "indent": 4, "text": ["Usually one will not directly access this but use the other\n    methods that provide bounds checked methods."], "extent": [28227, 28340]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.len"]}, " "], "role": "td", "extent": [28340, 28354], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The length of the attribute. This is the number of points,\n    primitives, or vertices it has."], "extent": [28354, 28453]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name"]}, ", ", {"type": "code", "text": ["@name.get"]}, " "], "role": "td", "extent": [28453, 28476], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The attribute value of the current index.  "], "extent": [28476, 28525]}, {"type": "para", "indent": 4, "text": ["Valid if readable.  Valid if not an array.  Valid if matching index."], "extent": [28525, 28598]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name(idx)"]}, ", ", {"type": "code", "text": ["@name.getAt(idx)"]}, " "], "role": "td", "extent": [28598, 28633], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Get the attribute at a specific index."], "extent": [28633, 28677]}, {"type": "para", "indent": 4, "text": ["Valid if readable.  Valid if not an array."], "extent": [28677, 28724]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.set(val)"]}, " "], "role": "td", "extent": [28724, 28743], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Set the attribute value at the current index.  "], "extent": [28743, 28796]}, {"type": "para", "indent": 4, "text": ["Vaild if writable.  Valid if not an array.  Valid if matching index."], "extent": [28796, 28869]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.setAt(idx, val)"]}, " "], "role": "td", "extent": [28869, 28895], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Set the attribute at the given index to the value.  "], "extent": [28895, 28953]}, {"type": "para", "indent": 4, "text": ["Valid if writable.  Valid if not an array."], "extent": [28953, 29000]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.tuplesize"]}, " "], "role": "td", "extent": [29000, 29020], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The size of each element of the attribute.  A float attribute has\n    size ", {"type": "code", "text": ["1"]}, ", a vector attribute would have size ", {"type": "code", "text": ["3"]}, "."], "extent": [29020, 29144]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.tuple"]}, " "], "role": "td", "extent": [29144, 29160], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A pointer to an array of the currently processed item.  This is\n    helpful if working with attribute sizes that do not map to OpenCL\n    native types.  To access the elements one would use ", {"type": "code", "text": ["[]"]}, ", as in\n    ", {"type": "code", "text": ["@name.tuple[2]"]}, " to get the third part of the current attribute.\n    Note in this case you must do bounds checking to ensure you do not\n    read past the attribute\u2019s tuplesize.   "], "extent": [29160, 29551]}, {"type": "para", "indent": 4, "text": ["Valid if matching index."], "extent": [29551, 29580]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.tupleAt(idx)"]}, " "], "role": "td", "extent": [29580, 29603], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A pointer to an array of a specific item at index ", {"type": "code", "text": ["idx"]}, ". Like\n    ", {"type": "code", "text": ["tuple"]}, ", care must be taken in using this."], "extent": [29603, 29716]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.bound"]}, " "], "role": "td", "extent": [29716, 29732], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Whether the attribute is bound or not.  For optional attributes\n    this can be 1 if bound and 0 if not.  Non-optional attributes are\n    always bound as the kernel will not be run if they aren\u2019t present."], "extent": [29732, 29941]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.comp(compidx)"]}, " "], "role": "td", "extent": [29941, 29965], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["For an array attribute, extracts a the specific component of the\n    current index\u2019s data.   "], "extent": [29965, 30064]}, {"type": "para", "indent": 4, "text": ["Valid if an array.  Valid if matching index."], "extent": [30064, 30113]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.entries"]}, " "], "role": "td", "extent": [30113, 30131], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The length of the current index\u2019s array.  "], "extent": [30131, 30179]}, {"type": "para", "indent": 4, "text": ["Valid if an array.  Valid if matching index."], "extent": [30179, 30228]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.compAt(idx, compidx)"]}, " "], "role": "td", "extent": [30228, 30259], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["For an array attribute, extracts the specific component of a\n    specific index\u2019s data.  ", {"type": "code", "text": ["idx"]}, " is the element number in the\n    attribute, ie, point number or primitive number.  ", {"type": "code", "text": ["compidx"]}, " is the\n    where in that element\u2019s array to access."], "extent": [30259, 30504]}, {"type": "para", "indent": 4, "text": ["Valid if an array."], "extent": [30504, 30527]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.entriesAt(idx)"]}, " "], "role": "td", "extent": [30527, 30552], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The length of the index ", {"type": "code", "text": ["idx"]}, "'s array."], "extent": [30552, 30596]}, {"type": "para", "indent": 4, "text": ["Valid if an array."], "extent": [30596, 30620]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Volume Binding Methods"], "extent": [30620, 30651], "body": [{"type": "para", "indent": 0, "text": ["Volumes on geometry can bound.  "], "extent": [30651, 30686]}, {"type": "para", "indent": 0, "text": ["A volume has a matching index if the kernel is running over a volume\nand the bound volume matches its resolution and transform."], "extent": [30686, 30815]}, {"type": "para", "indent": 0, "text": ["Volumes have a fair number of flags to add bind extra data that can be\nread by the methods.  Some methods may require extra flags to work,\nespecially if the volume isn\u2019t aligned with the volume being run over."], "extent": [30815, 31026]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [31026, 31036], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [31036, 31048]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.data"]}, " "], "role": "td", "extent": [31048, 31063], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The raw data of the volume.  This is a flat array of the volume\u2019s\n    values indexed using the ", {"type": "code", "text": ["stride_"]}, " values.  It is recommended to\n    use ", {"type": "code", "text": ["getAt"]}, " or similar methods rather than directly use the ", {"type": "code", "text": ["data"]}, "\n    as it will have bounds checking."], "extent": [31063, 31310]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.stride_x/y/z/offset"]}, " "], "role": "td", "extent": [31310, 31340], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The step size of the x, y, and z axes, along with the offset of\n    the 0,0,0 voxel from the start of the ", {"type": "code", "text": ["data"]}, " array."], "extent": [31340, 31464]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.x/y/zres"]}, " "], "role": "td", "extent": [31464, 31483], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The resolution of the volume.  Note it is often padded so the\n    stride must be used to index."], "extent": [31483, 31583]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.voxelsize_x/y/z"]}, " "], "role": "td", "extent": [31583, 31609], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The size of the 0,0,0 voxel along each of the axes."], "extent": [31609, 31666]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["voxelsize"]}, " flag."], "extent": [31666, 31697]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.xformtoworld"]}, " "], "role": "td", "extent": [31697, 31720], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A ", {"type": "code", "text": ["fpreal16"]}, " that maps a voxel index into the model/SOP space."], "extent": [31720, 31788]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["xformtoworld"]}, " flag."], "extent": [31788, 31822]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.xformtovoxel"]}, " "], "role": "td", "extent": [31822, 31845], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["A ", {"type": "code", "text": ["fpreal16"]}, " that maps a model/SOP space into index space."], "extent": [31845, 31909]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["xformtovoxel"]}, " flag."], "extent": [31909, 31943]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name"]}, ", ", {"type": "code", "text": ["@name.get"]}, " "], "role": "td", "extent": [31943, 31966], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The value of the volume at the current voxel index."], "extent": [31966, 32023]}, {"type": "para", "indent": 4, "text": ["Valid if readable.  Valid if matching index."], "extent": [32023, 32072]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.valid(x,y,z)"]}, " "], "role": "td", "extent": [32072, 32095], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["True if voxel x, y, z is within the bounds of the volume."], "extent": [32095, 32157]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.getAt(x,y,z)"]}, " "], "role": "td", "extent": [32157, 32180], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns the value at voxel (x, y, z).   If out of the range of the\n    volume, the index is clamped to the volume\u2019s range."], "extent": [32180, 32308]}, {"type": "para", "indent": 4, "text": ["Valid if readable."], "extent": [32308, 32331]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.set(val)"]}, " "], "role": "td", "extent": [32331, 32350], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets the currently processed voxel to ", {"type": "code", "text": ["val"]}, "."], "extent": [32350, 32400]}, {"type": "para", "indent": 4, "text": ["Valid if writable.  Valid if matching index."], "extent": [32400, 32449]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.setAt(x, y, z, val)"]}, " "], "role": "td", "extent": [32449, 32479], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets the voxel at (x, y, z) to ", {"type": "code", "text": ["val"]}, ".  This is bounds checked and\n    a no-op if it is out of range."], "extent": [32479, 32585]}, {"type": "para", "indent": 4, "text": ["Valid if writable."], "extent": [32585, 32608]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.sample(xyz)"]}, " "], "role": "td", "extent": [32608, 32630], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Trilinearly interpolates the volume at the index-space ", {"type": "code", "text": ["fpreal3"]}, "\n    location ", {"type": "code", "text": ["xyz"]}, ".  Clamps to within the valid range."], "extent": [32630, 32755]}, {"type": "para", "indent": 4, "text": ["Valid if readable."], "extent": [32755, 32778]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.sample2d(xy)"]}, " "], "role": "td", "extent": [32778, 32801], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Bilinearly interpolates the volume at the index-space ", {"type": "code", "text": ["fpreal2"]}, "\n    location ", {"type": "code", "text": ["xy"]}, ".  Clamps to within the valid range."], "extent": [32801, 32924]}, {"type": "para", "indent": 4, "text": ["Valid if readable."], "extent": [32924, 32949]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["VDB Binding Methods"], "extent": [32949, 32977], "body": [{"type": "para", "indent": 0, "text": ["VDBs on a geometry can bound.   VDBs in the OpenCL world have been\ntransformed into a NanoVDB layout.  While CNanoVDB and similar headers\ncan be used to directly access them, the methods provided will\nsimplify the access patterns so should be preferred."], "extent": [32977, 33233]}, {"type": "para", "indent": 0, "text": ["VDBs have a matching index if it is running over VDBs and the VDB has\nmatching transforms."], "extent": [33233, 33325]}, {"type": "para", "indent": 0, "text": ["While VDBs can be written to, doing so cannot change their topology.\nYou can only write to voxels that were already activated outside of\nOpenCL."], "extent": [33325, 33471]}, {"type": "para", "indent": 0, "text": ["VDBs have a fair number of flags to add bind extra data that can be\nread by the methods.  Some methods may require extra flags to work,\nespecially if the VDB isn\u2019t aligned with the VDB being run over."], "extent": [33471, 33673]}, {"type": "para", "indent": 0, "text": ["VDBs are usually bound explicitly to a type using the ", {"type": "code", "text": ["float"]}, " or\n", {"type": "code", "text": ["float3"]}, " type tags.  If no tag is specified, they are bound as ", {"type": "code", "text": ["any"]}, "\nand fewer methods are available."], "extent": [33673, 33841]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [33841, 33851], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [33851, 33863]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.data"]}, " "], "role": "td", "extent": [33863, 33878], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The raw NanoVDB data.   The ", {"type": "code", "text": ["CNanoVDB"]}, " header can be used to\n    inspect this directly, but using methods is the preferred approach\n    as CNanoVDB is very verbose."], "extent": [33878, 34047]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.voxelsize_x/y/z"]}, " "], "role": "td", "extent": [34047, 34073], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The size of the VDB (0,0,0) voxel in the x, y, and z axes."], "extent": [34073, 34137]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["voxelsize"]}, " flag."], "extent": [34137, 34168]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.xformtoworld"]}, " "], "role": "td", "extent": [34168, 34191], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["An ", {"type": "code", "text": ["fpreal16"]}, " transform from index space into model/SOP space."], "extent": [34191, 34259]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["xformtoworld"]}, " flag."], "extent": [34259, 34293]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.xformtovoxel"]}, " "], "role": "td", "extent": [34293, 34316], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["An ", {"type": "code", "text": ["fpreal16"]}, " transform from model/SOP space to index space."], "extent": [34316, 34382]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["xformtovoxel"]}, " flag."], "extent": [34382, 34416]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name"]}, ", ", {"type": "code", "text": ["@name.get"]}, " "], "role": "td", "extent": [34416, 34439], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns the value at the current processed index."], "extent": [34439, 34494]}, {"type": "para", "indent": 4, "text": ["Valid if readable.  Valid if matching index."], "extent": [34494, 34543]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.pos"]}, " "], "role": "td", "extent": [34543, 34557], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns the model/SOP location of the currently processed index."], "extent": [34557, 34627]}, {"type": "para", "indent": 4, "text": ["Valid if matching index."], "extent": [34627, 34656]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.active"]}, " "], "role": "td", "extent": [34656, 34673], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Whether the currently processed VDB index is active on this VDB."], "extent": [34673, 34743]}, {"type": "para", "indent": 4, "text": ["Requires ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Requires matching index."], "extent": [34743, 34811]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.activeAt(x, y, z)"]}, " "], "role": "td", "extent": [34811, 34839], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Whether the provided x, y, z index coordinates are active."], "extent": [34839, 34903]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding."], "extent": [34903, 34945]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.valid(x, y, z)"]}, " "], "role": "td", "extent": [34945, 34970], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Whether the provided x, y, z index coordinates are active."], "extent": [34970, 35034]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if matching index."], "extent": [35034, 35102]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.getAt(x, y, z)"]}, " "], "role": "td", "extent": [35102, 35127], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Returns the value at the index (x, y, z).  VDBs possess background\n    values in inactive areas so this can be run on any index."], "extent": [35127, 35261]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if readable."], "extent": [35261, 35323]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.set(val)"]}, " "], "role": "td", "extent": [35323, 35342], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets the currently processed voxel to the value ", {"type": "code", "text": ["val"]}, "."], "extent": [35342, 35402]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if writable.  Valid\n    if matching index."], "extent": [35402, 35494]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.setAt(x, y, z, val)"]}, " "], "role": "td", "extent": [35494, 35524], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Sets the voxel at index (x, y, z) to the value ", {"type": "code", "text": ["val"]}, ".  If the\n    index isn\u2019t in the VDBs topology the write will do nothing."], "extent": [35524, 35655]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if writable."], "extent": [35655, 35717]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.sample(xyz)"]}, " "], "role": "td", "extent": [35717, 35739], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Trilinearly interpolates the VDB at the provided index space\n    location."], "extent": [35739, 35819]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if readable."], "extent": [35819, 35881]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.worldSample(xyz)"]}, " "], "role": "td", "extent": [35881, 35908], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Trilinearly interpolates the VDB at the provided model/SOP space\n    location."], "extent": [35908, 35992]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["vector"]}, " or ", {"type": "code", "text": ["float"]}, " binding.  Valid if readable."], "extent": [35992, 36054]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name.worldGradient(xyz)"]}, " "], "role": "td", "extent": [36054, 36083], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Computes the gradient of the VDB at the provided model/SOP space\n    and returns the gradient in the modle/SOP space."], "extent": [36083, 36206]}, {"type": "para", "indent": 4, "text": ["Valid if ", {"type": "code", "text": ["float"]}, " binding.  Valid if readable."], "extent": [36206, 36257]}]}], "divider": false}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Option Binding Methods"], "extent": [36257, 36288], "body": [{"type": "para", "indent": 0, "text": ["Options on simulation data can be bound by the DOP OpenCL nodes."], "extent": [36288, 36355]}, {"type": "para", "indent": 0, "text": ["Which data to bind to is controlled by the ", {"type": "code", "text": ["geo"]}, " flag.  Which option\nis controled by the ", {"type": "code", "text": ["name"]}, " flag."], "extent": [36355, 36458]}, {"type": "table", "thead": [], "body": [{"type": "row", "body": [{"type": "cell", "indent": 0, "text": ["Method "], "role": "th", "extent": [36458, 36468], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["Meaning"], "extent": [36468, 36480]}]}], "divider": false}, {"type": "row", "body": [{"type": "cell", "indent": 0, "text": [{"type": "code", "text": ["@name"]}, ", ", {"type": "code", "text": ["@name.get"]}, " "], "role": "td", "extent": [36480, 36503], "container": true}, {"type": "cell", "role": "td", "body": [{"type": "para", "indent": 4, "text": ["The value of the option on the specified data."], "extent": [36503, 36555]}]}], "divider": false}]}]}]}], "title": ["OpenCL for VEX users"], "summary": ["OpenCL paradigms explained in terms of VEX."]}