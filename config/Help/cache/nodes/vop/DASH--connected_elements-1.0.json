{"type": "root", "attrs": {"icon": "/nodes/vop/DASH--connected_elements-1.0/DASH-connected_elements-icon.svg", "type": "node", "context": "vop", "internal": "connected_elements", "version": "1.0", "namespace": "DASH"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Connected Elements"], "extent": [49, 72]}, {"type": "summary", "indent": 0, "text": ["Returns an array of geometry elements connected to the input element."], "extent": [72, 150]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [150, 165], "body": [{"type": "para", "indent": 0, "text": ["This operator seeks to provide comprehensive functionality for the conversion of geometry elements into other connected elements. The main goals are:"], "extent": [165, 317]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Provide corresponding utility present in VEX with functions like ", {"scheme": "Vex", "value": "/vex/functions/pointprims", "type": "link", "text": "", "fallback_text": "pointprims()", "fullpath": "/vex/functions/pointprims.html"}, " or ", {"scheme": "Vex", "value": "/vex/functions/pointvertices", "type": "link", "text": "", "fallback_text": "pointvertices()", "fullpath": "/vex/functions/pointvertices.html"}, " which are missing in VOPs."], "extent": [317, 452]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Support conversions from and to edges. Optionally ignore equivalent half-hedges for source edges."], "extent": [452, 553]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Provide additional methods to reach the target elements, from the source, and index them as regions. There will be at least one region case (point:primitive), but it can go up to four region cases for (vertex:vertex)."], "extent": [553, 774]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Sort output elements clockwise in such way that can be used to create a polygon without intersecting edges."], "extent": [774, 885]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [885, 897], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Geometry"], "extent": [897, 908], "body": [{"type": "para", "indent": 4, "text": ["Source geometry to query."], "extent": [926, 957]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["opinput:#"]}, " will either source from an Attribute VOP input or from any valid spare input going up the node hierarchy. The default is the first input."], "extent": [957, 1113]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["op:/../.."]}, " will source from a node path. Must have geometry."], "extent": [1113, 1181]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": [{"type": "code", "text": ["/../.."]}, " location on disk of a geometry file. Supports environment variables, like ", {"type": "code", "text": ["$HOME"]}, ", ", {"type": "code", "text": ["$JOB"]}, ", ", {"type": "code", "text": ["$HIP"]}, ", etc."], "extent": [1181, 1301]}], "container": true}], "container": true, "attrs": {"id": "geometry"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Auto Element"], "extent": [1301, 1315], "body": [{"type": "para", "indent": 4, "text": ["Automatically infers the input element index from ", {"type": "code", "text": ["source:"]}, " class in ", {"type": "ui", "text": ["Connection"]}, ", i.e. ", {"type": "code", "text": ["point:*"]}, " conversion will use ", {"type": "code", "text": ["@ptnum"]}, ", or,  ", {"type": "code", "text": ["primitive:*"]}, " conversion will use ", {"type": "code", "text": ["@primnum"]}, ", etc. "], "extent": [1334, 1530]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [1530, 1540], "body": [{"type": "para", "indent": 8, "text": ["If the VOP runs in Detail, all of those variables will default to -1, so ", {"type": "ui", "text": ["Element"]}, " needs to be explicitly defined."], "extent": [1540, 1666]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "auto_elem"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Element 1"], "extent": [1666, 1677], "body": [{"type": "para", "indent": 4, "text": ["If a connection is made to the homonymous port it will override the ", {"type": "ui", "text": ["Auto Element"]}, " option.If used solo, it ought to be a linear vertex id or the half-edge id."], "extent": [1695, 1861]}], "container": true, "attrs": {"id": "element1"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Element 2"], "extent": [1861, 1872], "body": [{"type": "para", "indent": 4, "text": ["This index will be used in conjunction with ", {"type": "ui", "text": ["Element 1"]}, " for vertex or edge sourcing if either; ", {"type": "ui", "text": ["Auto Element"]}, " is ", {"type": "code", "text": ["OFF"]}, " and this value is greater than ", {"type": "code", "text": ["-1"]}, " or, if there is a connection on the homonymous port. "], "extent": [1890, 2108]}, {"type": "para", "indent": 4, "text": ["If so, vertices are sourced by a pair of primitive and local vertex, and, edges sourced by a pair of points. The pair of points will follow the rules in ", {"type": "ui", "text": ["Assess Input Edges"]}, " to determine which hedge is targeted by the pair."], "extent": [2108, 2339]}], "container": true, "attrs": {"id": "element2"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Connection"], "extent": [2339, 2351], "body": [{"type": "para", "indent": 4, "text": ["Defines the ", {"type": "code", "text": ["source:target"]}, " element classes for the conversion. All possible conversions are available in the menu with a letter next to it, indicating the maximum level of ", {"type": "ui", "text": ["Connectivity Regions"]}, " possible for them."], "extent": [2371, 2593]}], "container": true, "attrs": {"id": "connection"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Connectivity Regions"], "extent": [2593, 2615], "body": [{"type": "para", "indent": 4, "text": ["The connected elements are split into regions according how the ", {"type": "code", "text": ["target"]}, " elements are reached from the ", {"type": "code", "text": ["source"]}, " element. So each region can be toggled ON/OFF by this Button Strip but not all buttons are applicable to all conversion types. The maximum applicable region is stated in ", {"type": "ui", "text": ["Connection"]}, "'s drop-down menu."], "extent": [2647, 2967]}, {"type": "para", "indent": 4, "text": ["The index in the label to the right indicates the value sum that should be passed to the port to match the same outcome as this button strip. Moreover, each button will state its value needed to add to the input value sum to have it ", {"type": "code", "text": ["ON"]}, ", e.g. to have regions A and C ", {"type": "code", "text": ["ON"]}, ", pass ", {"type": "code", "text": ["5"]}, " in the port, i.e. ", {"type": "code", "text": ["1"]}, " + ", {"type": "code", "text": ["4"]}, ", respectively."], "extent": [2967, 3298]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [" ", {"scheme": "Image", "value": "/nodes/vop/DASH--connected_elements-1.0/DASH-connected_elements-help_regions_256.png", "type": "img", "text": ""}], "role": "item", "extent": [3298, 3370]}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "index"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Topological Order"], "extent": [3370, 3389], "body": [{"type": "para", "indent": 4, "text": ["By default, the simplest methods will be used to produce the selected ", {"type": "ui", "text": ["Adjacency Regions"]}, " elements without a specific individual order, only that elements from region A will come before elements from region B, etc. "], "extent": [3409, 3635]}, {"type": "para", "indent": 4, "text": ["However, this option will sort elements individually so they can be used more consistently to define a polygon\u2019s winding clockwise, without weird edge intersections. This addresses a common shortcoming with functions like ", {"scheme": "Vex", "value": "/vex/functions/neighbours", "type": "link", "text": "", "fallback_text": "neighbours()", "fullpath": "/vex/functions/neighbours.html"}, " and ", {"scheme": "Vex", "value": "/vex/functions/pointprims", "type": "link", "text": "", "fallback_text": "pointprims()", "fullpath": "/vex/functions/pointprims.html"}, " but, it is also fragile against improper/weird geometry and more expensive to compute."], "extent": [3635, 3991]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [" ", {"scheme": "Image", "value": "/nodes/vop/DASH--connected_elements-1.0/DASH-connected_elements-help_topoorder_256.png", "type": "img", "text": ""}], "role": "item", "extent": [3991, 4065]}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "topo_order"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "extent": [4065, 4076], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Assess Input Edges"], "extent": [4076, 4096], "body": [{"type": "para", "indent": 4, "text": ["Input edges can be sourced from a single hedge id (", {"type": "ui", "text": ["Element 1"]}, ") or a pair of point ids (", {"type": "ui", "text": ["Element 2"]}, " and ", {"type": "ui", "text": ["Element 2"]}, "). For the latter this parameter determines if either the order of the points targets strictly an hedge with matching source and destination points or if, failing that it falls back to any valid hedge with such pair (default behavior). "], "extent": [4118, 4481]}, {"type": "para", "indent": 4, "text": ["For both input methods, ", {"type": "ui", "text": ["Force Primary Hedge"]}, " will guarantee that whatever valid hedge is passed as input, the equivalent primary hedge is used as input instead."], "extent": [4481, 4650]}], "container": true, "attrs": {"id": "assess_edges"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Ignore Equivalent Hedges"], "extent": [4650, 4676], "body": [{"type": "para", "indent": 4, "text": ["When and only ", {"type": "ui", "text": ["Connection"]}, " source is ", {"type": "code", "text": ["edge:*"]}, " this will have the equivalent half-edges ignored and not used to reach the target elements."], "extent": [4701, 4846]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 4, "text": [" ", {"scheme": "Image", "value": "/nodes/vop/DASH--connected_elements-1.0/DASH-connected_elements-help_ignoreequiv_256.png", "type": "img", "text": ""}], "role": "item", "extent": [4846, 4922]}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "ignore_equiv   "}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "extent": [4922, 4930], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Description"], "extent": [4930, 4943], "body": [{"type": "para", "indent": 4, "text": ["String to replace any automatic description on top of the node in the network view. The pilcrow \u00b6 button enables multi-line text."], "extent": [4964, 5099]}], "container": true, "attrs": {"id": "description"}, "role": "item"}], "container": true, "role": "item_group"}, {"type": "load_example_group", "body": [{"ext": null, "type": "load_example", "indent": 0, "text": [" Connected Elements"], "role": "item", "extent": [5099, 5133], "body": [{"type": "para", "indent": 4, "text": ["This HDA example scene."], "extent": [5190, 5218]}], "container": true, "attrs": {"examplefile": "/demos/vop/connected_elements_demo.hda"}}], "container": true, "role": "item_group"}]}], "text": "Parameters"}], "title": ["Connected Elements"], "summary": ["Returns an array of geometry elements connected to the input element."]}