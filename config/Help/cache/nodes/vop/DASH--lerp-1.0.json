{"type": "root", "attrs": {"icon": "/nodes/vop/DASH--lerp-1.0/DASH-lerp-icon.svg", "type": "node", "context": "vop", "internal": "lerp", "version": "1.0", "namespace": "DASH"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Interpolate Unit by Range (lerp)"], "extent": [35, 72]}, {"type": "summary", "indent": 0, "text": ["Get the interpolated value, between two limit values, from a bias, ratio or unit position."], "extent": [72, 171]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/nodes/vop/DASH--lerp-1.0/DASH-invlerp-help_basic.svg", "type": "img", "text": ""}], "role": "item", "extent": [171, 221], "body": [{"type": "summary", "indent": 4, "text": ["Resulting value interpolated between First and Last based on a Bias unit value."], "extent": [245, 336]}], "container": true, "attrs": {"display": "wide left"}}], "container": true, "role": "item_group"}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [336, 342], "body": [{"type": "para", "indent": 4, "text": ["Vectors, Matrices and Arrays are treated as a package of floats and processed element-wise."], "extent": [342, 438]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["\u00a0 \u00a0 "], "extent": [438, 443], "body": [{"type": "para", "indent": 4, "text": ["Also, multidimensionals can have control signatures of multiple ranks. E.g. ", {"type": "code", "text": ["matrix2"]}, ": ", {"type": "code", "text": ["matrix2"]}, "(element-wise), ", {"type": "code", "text": ["float"]}, "(all)."], "extent": [443, 578]}], "container": true}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [578, 590], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["First / Last "], "extent": [590, 606], "body": [{"type": "para", "indent": 4, "text": ["Limit values to interpolate (or extrapolate) from."], "extent": [921, 977]}], "container": true, "attrs": {"id": "last_mp0"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Bias"], "extent": [977, 983], "body": [{"type": "para", "indent": 4, "text": ["Unit weight to map to ", {"type": "ui", "text": ["First"]}, " and ", {"type": "ui", "text": ["Last"]}, ", where ", {"type": "code", "text": ["0"]}, " matches the former and ", {"type": "code", "text": ["1"]}, " matches the latter."], "extent": [1102, 1214]}], "container": true, "attrs": {"id": "bias_mp6"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Invert: Last\u2192First"], "extent": [1214, 1234], "body": [{"type": "para", "indent": 4, "text": ["Swap the operands during the execution."], "extent": [1250, 1299]}], "container": true, "attrs": {"id": "invert"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Rounding"], "extent": [1299, 1316], "body": [{"type": "para", "indent": 0, "text": ["Integer Signatures will require converting from Float to Integer."], "extent": [1316, 1383]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Rounding Limit"], "extent": [1383, 1399], "body": [{"type": "para", "indent": 4, "text": ["Threshold limit for ", {"type": "ui", "text": ["Value"]}, "'s fractional part, that will determine if the rounding will be to the previous or the next index. E.g., a limit of ", {"type": "code", "text": ["0.3"]}, " will index a ", {"type": "ui", "text": ["Value"]}, " of ", {"type": "code", "text": ["5.4"]}, " to ", {"type": "code", "text": ["6"]}, ", since ", {"type": "code", "text": ["*.4"]}, " is to the right of the limit.\n    While this enables a custom rounding routine, it\u2019s basically a blend between the habitual rounding methods:"], "extent": [1414, 1764]}, {"type": "para", "indent": 4, "text": [{"type": "code", "text": ["1.0"]}, ": ", {"scheme": "Vex", "value": "/vex/functions/floor", "type": "link", "text": ["Floor"], "fallback_text": "floor()", "fullpath": "/vex/functions/floor.html"}, ". Default.", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, "\n    ", {"type": "code", "text": ["0.5"]}, ": ", {"scheme": "Vex", "value": "/vex/functions/rint", "type": "link", "text": ["Round"], "fallback_text": "rint()", "fullpath": "/vex/functions/rint.html"}, {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, "\n    ", {"type": "code", "text": ["0.0"]}, ": ", {"scheme": "Vex", "value": "/vex/functions/ceil", "type": "link", "text": ["Ceil"], "fallback_text": "ceil()", "fullpath": "/vex/functions/ceil.html"}], "extent": [1764, 1869]}], "container": true, "attrs": {"id": "limit"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Mirror"], "extent": [1869, 1877], "body": [{"type": "para", "indent": 4, "text": ["Rounding on the negative side will mirror the positive side. As it happens with ", {"scheme": "Vex", "value": "/vex/functions/trunc", "type": "link", "text": ["Truncate"], "fallback_text": "trunc()", "fullpath": "/vex/functions/trunc.html"}, " or ", {"type": "code", "text": ["int()"]}, " casting."], "extent": [1893, 2023]}], "container": true, "attrs": {"id": "mirror"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Inclusive"], "extent": [2023, 2034], "body": [{"type": "para", "indent": 4, "text": ["Determines if the ", {"type": "ui", "text": ["Limit"]}, " value itself will be rounded to the previous(", {"type": "em", "text": ["off"]}, ") or the next index(", {"type": "em", "text": ["on"]}, "). Only relevant when ", {"type": "ui", "text": ["Limit"]}, " is neither ", {"type": "code", "text": ["0"]}, " or ", {"type": "code", "text": ["1"]}, ", and can be a rare occasion."], "extent": [2053, 2243]}], "container": true, "attrs": {"id": "inclusive"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Presets"], "extent": [2243, 2252], "body": [{"type": "para", "indent": 4, "text": ["These buttons set ", {"type": "ui", "text": ["Limit"]}, ", ", {"type": "ui", "text": ["Mirror"]}, " and ", {"type": "ui", "text": ["Inclusive"]}, " parameters so that the rounding operation matches the label."], "extent": [2252, 2380]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Array Auto Resize"], "extent": [2380, 2406], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Common Size"], "extent": [2406, 2419], "body": [{"type": "para", "indent": 2, "text": ["Determines the size that all input arrays will have. ", {"type": "ui", "text": ["Min"]}, " will use the smallest array\u2019s size, while ", {"type": "ui", "text": ["Max"]}, " will use the greatest array\u2019s size."], "extent": [2448, 2598]}], "container": true, "attrs": {"id": "array_autoresize_size"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fill"], "extent": [2598, 2604], "body": [{"type": "para", "indent": 2, "text": ["Sized up arrays need a fill value. This determines whether the fill is the parameter\u2019s ", {"type": "em", "text": ["Default"]}, " or, if the array is not empty, its ", {"type": "em", "text": ["Last"]}, " or ", {"type": "em", "text": ["First"]}, " value."], "extent": [2633, 2793]}], "container": true, "attrs": {"id": "array_autoresize_fill"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "extent": [2793, 2803], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Description"], "extent": [2803, 2816], "body": [{"type": "para", "indent": 2, "text": ["String to display info on top of the node in the network view. The pilcrow \u00b6 button enables multi-line text."], "extent": [2835, 2947]}], "container": true, "attrs": {"id": "description"}, "role": "item"}], "container": true, "role": "item_group"}, {"type": "load_example_group", "body": [{"ext": null, "type": "load_example", "indent": 0, "text": [" Basic Math"], "role": "item", "extent": [2947, 2973], "body": [{"type": "para", "indent": 4, "text": ["Example scene for basic math operators."], "extent": [3022, 3065]}], "container": true, "attrs": {"examplefile": "/demos/vop/basic_math_demo.hda"}}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}], "title": ["Interpolate Unit by Range (lerp)"], "summary": ["Get the interpolated value, between two limit values, from a bias, ratio or unit position."]}