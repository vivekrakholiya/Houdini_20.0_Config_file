{"type": "root", "attrs": {"icon": "/nodes/sop/DASH--edges_to_lines-1.0/DASH-edges_to_lines-icon.svg", "type": "node", "context": "sop", "internal": "edges_to_lines", "version": "1.0", "namespace": "DASH"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Edges to Lines"], "extent": [45, 64]}, {"type": "summary", "indent": 0, "text": ["Create polylines or line segments from edges with extra info."], "extent": [64, 135]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [135, 150], "body": [{"type": "para", "indent": 0, "text": ["Convert edges to polylines or line segments. A line segment contains only two points and will match a single edge. A polyline can contain more than two points and traverse multiple edges. "], "extent": [150, 341]}, {"type": "para", "indent": 0, "text": ["Generate beginner friendly low level geometry that contains extra information about the input geometry. "], "extent": [341, 447]}, {"type": "para", "indent": 0, "text": ["This asset seeks to address some pitfalls present in either of ", {"scheme": "Node", "value": "/nodes/sop/convertline", "type": "link", "text": "", "fullpath": "/nodes/sop/convertline.html"}, " and ", {"scheme": "Node", "value": "/nodes/sop/polypath", "type": "link", "text": "", "fullpath": "/nodes/sop/polypath.html"}, " (seen in 19.5) and unify its use:"], "extent": [447, 591]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Winding based on polygon description, not point order."], "extent": [591, 648]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Options for the transfer of vertex and primitive Groups. The Attributes are just transferred using the first id, though."], "extent": [648, 771]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "ui", "text": ["Line Segments"]}, " can provide a lot of extra info about the input geometry."], "extent": [771, 849]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Extract only a select group of edges, not all."], "extent": [849, 898]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Possibility to output unused points or the remaining polygons with connecting lines."], "extent": [898, 986]}], "container": true}, {"type": "para", "indent": 0, "text": ["That said, internally it\u2019s using the Polypath tracing method for the Polyline option."], "extent": [986, 1073]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1073, 1085], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Edge Group"], "extent": [1085, 1098], "body": [{"type": "para", "indent": 4, "text": ["Group syntax that will scope the edges to be converted."], "extent": [1118, 1179]}], "container": true, "attrs": {"id": "edge_group"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Invert"], "extent": [1179, 1187], "body": [{"type": "para", "indent": 4, "text": ["Invert the outcome of the group syntax."], "extent": [1203, 1248]}], "container": true, "attrs": {"id": "invert"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Polylines"], "extent": [1248, 1264], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Close Ends"], "extent": [1264, 1277], "body": [{"type": "para", "indent": 4, "text": ["Determines if the output polyline will be closed into a polygon."], "extent": [1297, 1367]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Loop"], "extent": [1367, 1377], "body": [{"type": "para", "indent": 8, "text": ["Close if it\u2019s a loop, i.e. the start and end point are the same."], "extent": [1377, 1455]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Isolated Loops"], "extent": [1455, 1475], "body": [{"type": "para", "indent": 8, "text": ["Close the loop only if its end point is not shared with other polylines."], "extent": [1475, 1557]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "close_ends"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Discard Open"], "extent": [1557, 1571], "body": [{"type": "para", "indent": 4, "text": ["Only output closed loops."], "extent": [1593, 1625]}], "container": true, "attrs": {"id": "discard_open"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Line Segments"], "extent": [1625, 1645], "body": [{"type": "para", "indent": 0, "text": ["Extra attributes available for line segments concerning the input geometry:"], "extent": [1645, 1722]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Length"], "extent": [1722, 1730], "body": [{"type": "para", "indent": 4, "text": ["Line segment length.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:flt"]}], "extent": [1765, 1810]}], "container": true, "attrs": {"id": "length"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Delta"], "extent": [1810, 1817], "body": [{"type": "para", "indent": 4, "text": ["Vector direction from source point to destination point with the option to normalize it.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:vec3"]}], "extent": [1875, 1989]}], "container": true, "attrs": {"id": "delta_normalize"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Elements Indices"], "extent": [1989, 2014], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Points Pairs"], "extent": [2014, 2029], "body": [{"type": "para", "indent": 4, "text": ["Indices of the input points that belong to the edge.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int[]"]}], "extent": [2072, 2151]}], "container": true, "attrs": {"id": "ptpairsatt"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Primary Hedge"], "extent": [2151, 2166], "body": [{"type": "para", "indent": 4, "text": ["Unique input primary hedge index.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int"]}], "extent": [2209, 2267]}], "container": true, "attrs": {"id": "main_hgatt"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Primary Primitive"], "extent": [2267, 2286], "body": [{"type": "para", "indent": 4, "text": ["Unique input primitive index from primary hedge.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int[]"]}], "extent": [2329, 2404]}], "container": true, "attrs": {"id": "main_pmatt_on"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Primary Vertex"], "extent": [2404, 2420], "body": [{"type": "para", "indent": 4, "text": ["Unique input vertex index from primary hedge.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["vtx:int"]}], "extent": [2461, 2531]}], "container": true, "attrs": {"id": "vtxsatt"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Options"], "extent": [2531, 2545], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Output"], "extent": [2545, 2554], "body": [{"type": "para", "indent": 4, "text": ["Determines what should be output from the geometry not included in the lines."], "extent": [2575, 2658]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Lines Only"], "extent": [2658, 2674], "body": [{"type": "para", "indent": 8, "text": ["Outputs only the extracted edges into lines."], "extent": [2674, 2728]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Keep Unused Points"], "extent": [2728, 2752], "body": [{"type": "para", "indent": 8, "text": ["Outputs the extracted lines along with unused points."], "extent": [2752, 2819]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Keep Other Geo + Links"], "extent": [2819, 2847], "body": [{"type": "para", "indent": 8, "text": ["Outputs extracted lines, the remaining polygons and line segments connecting them."], "extent": [2847, 2939]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "output_type"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Piece Attribute"], "extent": [2939, 2956], "body": [{"type": "para", "indent": 4, "text": ["Attribute that classifies the geometry based on the ", {"type": "ui", "text": ["Output"]}, " method. Point attribute for ", {"type": "code", "text": ["Keep Unused Points"]}, ". Primitive attribute for ", {"type": "code", "text": ["Keep Other Geo + Links"]}, ".\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["pnt/prim:str"]}], "extent": [2975, 3167]}], "container": true, "attrs": {"id": "piece_att"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "extent": [3167, 3177], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Preserve Winding"], "extent": [3177, 3195], "body": [{"type": "para", "indent": 4, "text": ["Reverse polylines when necessary to make them follow the input polygons' winding as best possible. Trickier for polylines as their multiple edges are taken into account."], "extent": [3221, 3396]}], "container": true, "attrs": {"id": "preserve_winding"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Elements Indices and Types"], "extent": [3396, 3431], "body": [{"type": "para", "indent": 0, "text": ["Attributes that hold information about input elements as well as the generated line network."], "extent": [3431, 3526]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Point"], "extent": [3526, 3533], "body": [{"type": "para", "indent": 4, "text": ["Input point index.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["pnt:int"]}], "extent": [3570, 3613]}], "container": true, "attrs": {"id": "ptidatt_on"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Traversed Hedges"], "extent": [3613, 3631], "body": [{"type": "para", "indent": 4, "text": ["All equivalent input hedge indices that match the edge.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int[]"]}], "extent": [3666, 3748]}], "container": true, "attrs": {"id": "hgsatt"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Traversed Primitives"], "extent": [3748, 3770], "body": [{"type": "para", "indent": 4, "text": ["Input prim indices which are bordered by the edge. \n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int[]"]}], "extent": [3805, 3887]}], "container": true, "attrs": {"id": "pmsatt_on"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Traversed Vertices"], "extent": [3887, 3907], "body": [{"type": "para", "indent": 4, "text": ["Indices of input vertices bordered by the edge at that point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["vtx:int[]"]}], "extent": [3942, 4034]}], "container": true, "attrs": {"id": "vtsatt"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Point Type"], "extent": [4034, 4046], "body": [{"type": "para", "indent": 4, "text": ["Classification of output points according to their role on polygons. \n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["pnt:int"]}], "extent": [4087, 4181]}, {"type": "para", "indent": 4, "text": [{"type": "code", "text": ["0"]}, ": Open end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["1"]}, ": Polylines mid point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["2"]}, ": Polylines' shared end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["3"]}, ": Shared point that belong to as many primitives as it has neighbors.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["4"]}, ": Shared point that belongs to at least a loop.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["-1"]}, ": Not classified"], "extent": [4181, 4457]}], "container": true, "attrs": {"id": "pttypeatt_on"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Primitive Type"], "extent": [4457, 4473], "body": [{"type": "para", "indent": 4, "text": ["Classification of the output primitive according to their end points. \n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["prm:int"]}], "extent": [4514, 4609]}, {"type": "para", "indent": 4, "text": [{"type": "code", "text": ["0"]}, ": Two-point primitive with both end points open.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["1"]}, ": Two-point primitive with one open end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["2"]}, ": Two-point primitive with both ends points open.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["3"]}, ": Non-looping polyline with both end points open.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["4"]}, ": Non-looping polyline with one open end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["5"]}, ": Non-looping polyline with both ends points shared.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["6"]}, ": Isolated looping polyline, i.e. endpoint is unshared.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["7"]}, ": Looping polyline with shared end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["8"]}, ": Isolated looping closed polyline, i.e. endpoint is unshared.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["9"]}, ": Closed looping polyline with shared end point.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "code", "text": ["-1"]}, ": Not classified"], "extent": [4609, 5262]}], "container": true, "attrs": {"id": "pmtypeatt_on"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Primitive & Vertex Groups"], "extent": [5262, 5294], "body": [{"type": "para", "indent": 0, "text": ["Primitive and vertex groups are trickier to transfer because the same line could be connected to multiple of said elements. The following are used to control the logic of said inference."], "extent": [5294, 5482]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Promotion"], "extent": [5482, 5493], "body": [{"type": "para", "indent": 4, "text": ["Logic used to match the group membership of an output vertex or pimitive based on all the group memberships of input elements they line traverses. "], "extent": [5555, 5708]}, {"type": "para", "indent": 4, "text": [{"type": "ui", "text": ["First"]}, ": First element.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["Last"]}, ": Last element.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["Single"]}, ": Exactly one element.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["Twice"]}, ": Exactly two elements.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["Any"]}, ": At least one element.\n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["All"]}, ": All elements. \n    ", {"tag": "br", "attrs": {}, "type": "xml", "text": ""}, {"type": "ui", "text": ["Average"]}, ": At least half of the elements."], "extent": [5708, 5982]}], "container": true, "attrs": {"id": "vertex_match_promotion"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Invert"], "extent": [5982, 5990], "body": [{"type": "para", "indent": 4, "text": ["Invert the outcome determined by ", {"type": "ui", "text": ["Promotion"]}, "."], "extent": [6046, 6099]}], "container": true, "attrs": {"id": "vertex_match_invert"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Copy Empty / Unused"], "extent": [6099, 6120], "body": [{"type": "para", "indent": 4, "text": ["Determines if groups that are either empty (without elements in input) or unused (without elements in output) are present in the output."], "extent": [6172, 6314]}], "container": true, "attrs": {"id": "vertex_copy_empty"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "extent": [6314, 6324], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Description"], "extent": [6324, 6337], "body": [{"type": "para", "indent": 4, "text": ["String to replace any automatic description on top of the node in the network view. The pilcrow \u00b6 button enables multi-line text."], "extent": [6358, 6493]}], "container": true, "attrs": {"id": "description"}, "role": "item"}], "container": true, "role": "item_group"}, {"type": "load_example_group", "body": [{"ext": null, "type": "load_example", "indent": 0, "text": [" Edges to Lines"], "role": "item", "extent": [6493, 6523], "body": [{"type": "para", "indent": 4, "text": ["This HDA example scene."], "extent": [6576, 6603]}], "container": true, "attrs": {"examplefile": "/demos/sop/edges_to_lines_demo.hda"}}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}], "title": ["Edges to Lines"], "summary": ["Create polylines or line segments from edges with extra info."]}