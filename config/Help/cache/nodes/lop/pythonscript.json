{"type": "root", "attrs": {"type": "node", "context": "lop", "internal": "pythonscript", "icon": "MISC/python", "group": "util", "since": "17.0", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Python Script"], "extent": [0, 18]}, {"type": "summary", "indent": 0, "text": ["Lets you write Python code in the node to use the USD API to directly manipulate the stage."], "extent": [114, 214]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [214, 229], "body": [{"type": "para", "indent": 0, "text": ["For technical or integration tasks that would be difficult to express using LOP nodes, you can use this node to access the full power of the ", {"scheme": null, "value": "https://graphics.pixar.com/usd/docs/USD-Developer-API-Reference.html", "type": "link", "text": ["USD API"], "exists": true}, " to read and modify the scene graph tree, the power of ", {"scheme": null, "value": "/hom/hou/", "type": "link", "text": ["HOM"], "fullpath": "/hom/hou/index.html"}, " to access and control the rest of Houdini, as well as the full power of Python and its libraries to access external data and integrate with your pipeline and other systems."], "extent": [229, 694]}, {"type": "para", "indent": 0, "text": ["This node is often useful to script custom pipeline-specific tasks."], "extent": [694, 763]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "https://graphics.pixar.com/usd/docs/USD-Tutorials.html", "type": "link", "text": ["Pixar\u2019s Python API tutorials"], "exists": true}, " for help with the APIs."], "extent": [763, 879]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Scripting the stage"], "extent": [879, 905], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Call ", {"type": "code", "text": ["hou.pwd()"]}, " to get a reference to this node as a ", {"scheme": "Hom", "value": "/hom/hou/Node", "type": "link", "text": "", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node.html"}, ". You can get ", {"type": "em", "text": ["either"]}, " the current stage through this reference (see below). You can also use it to access spare parameters you might add to this node."], "extent": [905, 1129]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Call ", {"type": "code", "text": ["hou.pwd().editableStage()"]}, " to get an editable ", {"type": "code", "text": ["pxr.Usd.Stage"]}, " object. This represents the output of this node, including any changes you make using the API."], "extent": [1129, 1295], "body": [{"type": "para", "indent": 4, "text": ["(The USD Edit Target is automatically set to the active layer for you. ", {"type": "strong", "text": ["Do not change the edit target"]}, ". Doing so will have unpredictable negative consequences.)"], "extent": [1295, 1465]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Call ", {"type": "code", "text": ["hou.pwd().inputs()[0].stage()"]}, " to read from an input stage, then stash any evaluated prim patterns or other values, **before** calling ", {"type": "code", "text": ["hou.pwd().editablestage()"]}, ". When this happens in the wrong order, Houdini will still usually run the code, but will not be as efficient."], "extent": [1465, 1748]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Examples"], "extent": [1748, 1763], "body": [{"type": "box_group", "body": [{"ext": null, "type": "box", "indent": 0, "text": [" Add new prims to the stage"], "role": "item", "extent": [1763, 1798], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    stage = hou.pwd().editableStage()\n    xform = stage.DefinePrim('/shapes', 'Xform')\n    cube = stage.DefinePrim('/shapes/cube1', 'Cube')\n    "], "extent": [1798, 1967]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": [" Loop over every prim in the scene graph tree"], "role": "item", "extent": [1967, 2020], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    stage = hou.pwd().editableStage()\n    for prim in stage.Traverse():\n        # Access or edit the prim\n        pass\n    "], "extent": [2020, 2168]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": [" Use USD\u2019s high-level APIs to manipulate complex attributes"], "role": "item", "extent": [2168, 2235], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    from pxr import UsdGeom\n\n    stage = hou.pwd().editableStage()\n    cube = stage.GetPrimAtPath(\"/shapes/cube1\")\n\n    # Change attributes directly\n    cube.GetAttribute(\"size\").Set(1.5)\n\n    # APIs can have useful shortcuts\n    cube_api = UsdGeom.Cube(cube)\n    color = cube_api.GetDisplayColorAttr()\n    color.Set([(0, 0, 1.0)])\n\n    # Use the XformCommonAPI to manipulate transforms instead of messing\n    # with matrix attributes directly\n    UsdGeom.XformCommonAPI(cube).SetTranslate((4, 5, 6))\n    "], "extent": [2235, 2765]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": [" Loop over all lights, copying their exposure into their intensity and clearing the exposure"], "role": "item", "extent": [2765, 2865], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    from pxr import UsdLux\n\n    stage = hou.pwd().editableStage()\n\n    # UsdLux has a special API for finding all lights in the scene efficiently\n    api = UsdLux.ListAPI(stage.GetPseudoRoot())\n    for lightprim in light api.ComputeLightList():\n        exposure_attr = lightprim.GetAttribute(\"exposure\")\n        intensity_attr = lightprim.GetAttribute(\"intensity\")\n\n        intensity = intensity_attr.Get()\n        exposure = exposure_attr.Get()\n        if exposure:\n            intensity_attr.Set(intensity * (exposure ** 2))\n            exposure_attr.Set(0)\n    "], "extent": [2865, 3454]}], "container": true}, {"ext": null, "type": "box", "indent": 0, "text": [" Reduce the intensity of all lights to half their current values, using a\n", {"scheme": "Hom", "value": "/hom/hou/LopSelectionRule", "type": "link", "text": "", "fallback_text": "hou.LopSelectionRule", "fullpath": "/hom/hou/LopSelectionRule.html"}, "."], "role": "item", "extent": [3454, 3563], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    node = hou.pwd()\n\n    # First, find all the light prims on our input.\n    # We must do this before getting our editable stage to\n    # avoid an expensive recook of the input node.\n    ls = hou.LopSelectionRule()\n    ls.setPathPattern('{ usd_istype(0, @primpath, \"UsdLuxLight\") }')\n    paths = ls.expandedPaths(node.inputs()[0])\n\n    # Now that we have our set of prim path, we can get the\n    # editable stage and start making changes.\n    stage = node.editableStage()\n    for path in paths:\n        prim = stage.GetPrimAtPath(path)\n        intensity = prim.GetAttribute('intensity')\n        intensity.Set(intensity.Get() * 0.5)\n    "], "extent": [3563, 4225]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "editlayer", "container": true, "type": "h", "indent": 0, "text": ["Scripting the active layer instead"], "extent": [4225, 4279], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"type": "strong", "text": ["Instead of"]}, " manipulating the stage using ", {"type": "code", "text": ["Usd"]}, " APIs, you can edit the active layer using lower-level ", {"type": "code", "text": ["Sdf"]}, " APIs. ", {"type": "strong", "text": ["You cannot do both in the same script"]}, "."], "extent": [4279, 4438]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You probably only want to do this if you have a reason to prefer the lower-level APIs. ", {"type": "code", "text": ["pxr.Usd"]}, " methods are higher level methods that can be much easier to use. They perform more error checking and data validation. However the ", {"type": "code", "text": ["pxr.Sdf"]}, " APIs can be dramatically faster, especially when creating new USD primitives."], "extent": [4438, 4757]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["To get an editable ", {"type": "code", "text": ["pxr.Sdf.Layer"]}, " reference to the active layer, call ", {"type": "code", "text": ["hou.pwd().editableLayer()"]}, ". If you do this, do ", {"type": "em", "text": ["not"]}, " also call ", {"type": "code", "text": ["hou.pwd().editableStage()"]}, " in the same script."], "extent": [4757, 4943]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["With an ", {"type": "code", "text": ["Sdf.ChangeBlock()"]}, ", you can further improve performance by batching all of your changes together. This lets USD processes them all at once."], "extent": [4943, 5096]}], "container": true}]}, {"level": 2, "id": "tips", "container": true, "type": "h", "indent": 0, "text": ["Tips"], "extent": [5096, 5114], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["When you are editing code, the node will cook if you click outside the editor, or press ", {"keys": ["Alt", "Enter"], "type": "keys", "text": null}, "."], "extent": [5114, 5223]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can add ", {"scheme": null, "value": "/network/spare", "type": "link", "text": ["spare parameters"], "fullpath": "/network/spare.html"}, " onto the node to give the node a graphical interface. For example, you could add a text box named ", {"type": "code", "text": ["primpath"]}, " that takes a primitive path. Then you can access the parameter value in the script:"], "extent": [5223, 5465], "body": [{"lang": "python", "type": "pre", "indent": 4, "text": ["\n    node = hou.pwd()\n    primpath = node.evalParm(\"primpath\")\n    "], "extent": [5465, 5556]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If you make a useful Python Script node you want to share, you can turn a node instance into a LOP digital asset. Right-click the node in the network editor and choose ", {"type": "ui", "text": ["Create digital asset"]}, ". The script is stored as part of the digital asset, and the node functions the same way, but as an asset that can be shared and versioned."], "extent": [5556, 5892]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The pop-up menu button to the right of the editor pulls snippets from any ", {"type": "code", "text": ["PythonScripts.txt"]}, " files in the Houdini path. You can create a ", {"type": "code", "text": ["$HOUDINI_USER_PREFS_DIR/PythonScripts.txt"]}, " file and add snippets to have them appear in this menu. Read ", {"type": "code", "text": ["$HFS/houdini/PythonScripts.txt"]}, " to see the required file format."], "extent": [5892, 6204]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["If your script needs to ", {"type": "q", "text": ["find all prims that\u2026"]}, ", instead of using the USD traversal methods, consider using ", {"scheme": "Hom", "value": "/hom/hou/LopSelectionRule", "type": "link", "text": "", "fallback_text": "hou.LopSelectionRule", "fullpath": "/hom/hou/LopSelectionRule.html"}, ". This object implements Houdini\u2019s ", {"scheme": null, "value": "/solaris/pattern", "type": "link", "text": ["USD prim pattern matching"], "fullpath": "/solaris/pattern.html"}, ". It generates a list of ", {"type": "code", "text": ["Sdf.Path"]}, " objects. You can turn an ", {"type": "code", "text": ["Sdf.Path"]}, " into a ", {"type": "code", "text": ["Usd.Prim"]}, " object using ", {"type": "code", "text": ["stage.GetPrimAtPath(pathstring)"]}, ". When using this approach you can either evaluate the selection rule on the input node, or directly on the ", {"type": "code", "text": ["Usd.Stage"]}, " returned by ", {"type": "code", "text": ["pwd().editableStage()"]}, ". If using the input node, evaluate the selection rule before getting this node\u2019s editable stage to avoid an expensive duplication of the input stage."], "extent": [6204, 6863]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["It is almost always a bad idea to call ", {"scheme": "Hom", "value": "/hom/hou/setContextOption", "type": "link", "text": "", "fallback_text": "hou.setContextOption", "fullpath": "/hom/hou/setContextOption.html"}, " from within the script of a Python LOP. This causes a global context option to be created. Global context options are accessible anywhere in the hip file, which means cooking this LOP and running its script can potentially cause nodes anywhere else in the hip file to become dirty, if they use this context option. Further, the global context option will only be set when the node cooks, but changing the global context option value in the ", {"scheme": null, "value": "/ref/contextoptions", "type": "link", "text": ["context option editor"], "fullpath": "/ref/contextoptions.html"}, " or using Python code (in a python shell or in another Python LOP) will not dirty this node, and so it will not recook and reset the option value as might be expected. Instead, setting context options locally within a LOP network should be done using the ", {"scheme": "Node", "value": "/nodes/lop/editcontextoptions", "type": "link", "text": ["Edit Context Options LOP"], "fullpath": "/nodes/lop/editcontextoptions.html"}, "."], "extent": [6863, 7726]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You must not edit the root layer of the stage. Although this root layer is accessible through the Python API, the LOP cooking architecture requires that it be free to manage that root layer free from interference from any single LOP node. The most common use case that leads to this mistake is wanting to add a sublayer to the root layer, which can instead be done using the ", {"scheme": "Hom", "value": "/hom/hou/LopNode#addSubLayer", "type": "link", "text": "", "fallback_text": "hou.LopNode.addSubLayer", "fullpath": "/hom/hou/LopNode.html#addSubLayer", "fragment": "#addSubLayer"}, " method."], "extent": [7726, 8143]}], "container": true}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [8143, 8155], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Python Code"], "extent": [8155, 8169], "body": [{"type": "para", "indent": 4, "text": ["The Python code to run when cooking this node. See the main help above for tips and examples."], "extent": [8169, 8268]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Maintain State"], "extent": [8268, 8284], "body": [{"type": "para", "indent": 4, "text": ["When enabled, the underlying Python interpreter will not be cleared between cooks. This may give some performance gains, but can also lead to unexpected behaviour. It is generally recommended to leave this disabled."], "extent": [8284, 8506]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}], "title": ["Python Script"], "summary": ["Lets you write Python code in the node to use the USD API to directly manipulate the stage."]}